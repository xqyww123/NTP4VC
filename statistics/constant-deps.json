{"Axiomatic13.p_valid_memb": ["$le", "Memory.Memory.shift", "$times", "HOL.eq", "HOL.Let", "$lt", "Memory.Memory.valid_rw", "HOL.conj", "Memory.Memory.separated"], "Axiomatic13.p__memb_full": ["$le", "Memory.Memory.shift", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "$lt", "HOL.Not"], "Axiomatic13.l__memb_index": ["Memory.Memory.shift", "int.ComputerDivision.div", "$eq", "$minus", "Memory.Memory.offset"], "Axiomatic13.l__memb_ptr": ["$times", "Memory.Memory.shift", "$eq"], "Axiomatic13.p__memb_has": ["$le", "Memory.Memory.shift", "HOL.eq", "HOL.Ex", "$eq", "$lt", "l__memb_ptr", "HOL.conj"], "Axiomatic13.p__memb_allocated": ["Memory.Memory.shift", "l__memb_index", "HOL.eq", "$eq", "HOL.Not", "p__memb_has", "HOL.conj"], "Axiomatic13.l__memb_numfree": ["A_OccArray.A_OccArray.l_occ_a", "Memory.Memory.shift", "$eq"], "Axiomatic13.p__memb_empty": ["$le", "Memory.Memory.shift", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "$lt"], "verifythis_2017_odd_even_transposition_sort.odd_sorted": ["$le", "nat$nth", "HOL.All", "HOL.implies", "HOL.eq", "$times", "$lt", "Int.nat", "$plus"], "verifythis_2017_odd_even_transposition_sort.even_sorted": ["$le", "nat$nth", "HOL.All", "HOL.implies", "HOL.eq", "$times", "$lt", "Int.nat", "$plus"], "same_fringe.elements": ["list.List.Nil", "$append", "$eq", "list.List.Cons"], "same_fringe.enum_elements": ["$append", "$eq", "list.List.Cons", "elements", "list.List.Nil"], "split_string.notin": ["List.set", "HOL.eq", "contents'", "HOL.Not", "Set.member"], "sumrange.indexes1": ["$eq"], "sumrange.is_indexes_for": ["$le", "ArraySum.sum", "isum", "HOL.eq", "Int.int", "$eq", "$lt", "low", "high", "HOL.conj", "length$nat"], "sumrange.is_tree_for": ["indexes1", "$plus", "int.ComputerDivision.div", "HOL.eq", "$eq", "HOL.Let", "$lt", "low", "high", "HOL.conj", "is_indexes_for"], "relabel.labels": ["list.List.Nil", "list.List.Cons", "$eq", "$append"], "relabel.same_shape": [], "sumrange.depth": ["int.MinMax.max", "$plus", "$eq"], "sumrange.is_cumulative_array_for": ["$le", "nat$nth", "HOL.All", "HOL.conj", "ArraySum.sum", "HOL.eq", "Int.int", "HOL.implies", "$eq", "$lt", "Int.nat", "$plus", "length$nat"], "queue_two_lists.t'eq": ["HOL.eq", "seq", "rear", "$eq", "front", "HOL.conj"], "max_matrix.solution": ["$le", "n", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "$lt", "HOL.Not", "HOL.conj"], "max_matrix.f": ["mixfix_lbrb", "m", "$eq"], "isqrt_von_neumann.sqr": ["$times", "$eq"], "isqrt_von_neumann.is_pow2": ["lsl$nat", "$unat", "HOL.eq", "$eq", "bit$and", "$minus"], "max_matrix.pre": ["$le", "Bitset.cardinal", "n", "HOL.All", "HOL.eq", "HOL.implies", "$eq", "$lt", "$minus", "HOL.conj", "Bitset.mem"], "max_matrix.post": ["$le", "n", "HOL.All", "HOL.conj", "solution", "HOL.eq", "HOL.implies", "$eq", "sum", "$lt", "contents", "mixfix_lbrb", "Bitset.mem"], "max_matrix.inv": ["HashTable.mixfix_lbrb", "HOL.All", "HOL.implies", "HOL.eq", "post", "$eq", "option.Option.Some"], "bitvector_examples.in_range": ["HOL.eq", "HOL.conj", "$le"], "bitvector_examples.add_over": ["HOL.eq", "$plus", "HOL.conj", "$ge"], "kleene_algebra.one": ["set.Set.all1", "fc", "set.Set.map", "$eq"], "kleene_algebra.post": ["result", "set.Set.filter", "set.Set.map", "$eq", "result1"], "kleene_algebra.pre": ["set.Set.filter", "set.Set.map", "$eq", "result3", "result2"], "kleene_algebra.infix_as": ["set.Set.all1", "set.Set.filter", "$eq", "result4"], "hackers_delight.validAscii": ["$unat", "HOL.eq", "$eq", "$neq", "take_bit$nat", "why3.Bool.Bool.False", "Utils.count"], "kleene_algebra.infix_lseq": ["HOL.eq", "infix_pl", "set.Set.union", "$eq"], "kleene_algebra.in_star": ["set.Set.mem"], "kleene_algebra.prefix_ex": ["set.Set.all1", "in_star_closure", "$eq", "set.Set.filter"], "hackers_delight.toGray": ["lsr$nat", "$unat", "bit$xor", "$eq"], "hackers_delight.fromGray": ["$unat", "lsr$nat", "$eq", "HOL.Let", "bit$xor"], "patience.inv": ["num_stacks", "$le", "positions", "HOL.All", "num_elts", "HOL.If", "values", "HOL.eq", "HOL.implies", "$eq", "HOL.Let", "$lt", "$minus", "preds", "stacks1", "HOL.conj", "$uminus", "stack_sizes"], "patience.increasing_subsequence": ["$le", "seqlen", "nat$nth", "seqval", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.implies", "$lt", "Int.nat", "length$nat"], "hackers_delight.nth_diff": ["HOL.eq", "$eq", "$neq", "take_bit$nat", "HOL.Not", "Int.nat"], "hackers_delight.addDontOverflow": ["HOL.eq", "$plus", "HOL.conj", "$le"], "mergesort_array.sorted_sub": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$lt", "le", "Int.nat"], "mergesort_array.sorted": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$lt", "le", "Int.nat", "length$nat"], "patience.wf_stacks": ["HOL.eq", "HOL.True", "HOL.False"], "sf.even": [], "patience.range": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$lt", "HOL.conj"], "patience.injective": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "$lt", "HOL.Not", "HOL.conj"], "sf.sum": ["$plus", "$eq"], "foveoos11_challenge2.size": ["$plus", "$eq"], "foveoos11_challenge2.mem": ["HOL.eq", "HOL.disj", "HOL.False", "$eq"], "verifythis_2018_array_based_queuing_lock_2.tick'eq": ["HOL.eq", "$eq", "v", "HOL.conj", "b"], "verifythis_2018_array_based_queuing_lock_2.lt": ["HOL.eq", "$lt", "v"], "verifythis_2018_array_based_queuing_lock_2.sorted": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$lt", "Int.nat", "lt", "length$nat"], "verifythis_2018_array_based_queuing_lock_2.consecutive": ["nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "Int.int", "HOL.eq", "$eq", "$lt", "$minus", "v", "Int.nat", "$plus", "length$nat"], "verifythis_2018_array_based_queuing_lock_2.last": ["nat$nth", "HOL.If", "option.Option.None", "Int.int", "$eq", "$minus", "Int.nat", "option.Option.Some", "length$nat"], "verifythis_2018_array_based_queuing_lock_2.hd": ["nat$nth", "HOL.If", "option.Option.None", "Int.int", "$eq", "option.Option.Some", "length$nat"], "conjugate.is_partition": ["$le", "nat$nth", "HOL.All", "HOL.conj", "mach.int.Int32.int32'int", "HOL.eq", "Int.int", "HOL.implies", "$eq", "mach.array.Array32.length", "$lt", "$minus", "Int.nat", "mach.array.Array32.mixfix_lbrb", "length$nat"], "verifythis_2018_array_based_queuing_lock_2.has_ticket": ["HOL.eq", "HOL.True", "HOL.False"], "conjugate.numofgt": ["$le", "nat$nth", "HOL.All", "HOL.conj", "mach.int.Int32.int32'int", "HOL.eq", "Int.int", "HOL.implies", "mach.array.Array32.length", "$lt", "Int.nat", "mach.array.Array32.mixfix_lbrb", "length$nat"], "verifythis_2018_array_based_queuing_lock_2.has_lock": ["HOL.eq", "HOL.True", "HOL.False"], "conjugate.is_conjugate": ["$le", "numofgt", "nat$nth", "HOL.All", "HOL.conj", "mach.int.Int32.int32'int", "HOL.eq", "Int.int", "HOL.implies", "mach.array.Array32.length", "$lt", "Int.nat", "mach.array.Array32.mixfix_lbrb", "length$nat"], "optimal_replay.path": ["$le", "$lt", "n", "f"], "optimal_replay.distance": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "HOL.conj", "path"], "kleene_algebra.infix_lseq1": ["HOL.eq", "set.Set.union", "$eq"], "zeros.all_zeros": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$eq", "$lt", "Int.nat"], "zeros.zero_interval": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$eq", "$lt", "Int.nat"], "my_bag.numof": ["fc", "int.NumOf.numof", "$eq"], "my_bag.t'eq": ["HOL.eq", "data", "$eq", "contents", "HOL.conj", "size"], "hillel_challenge.big'eq": ["HOL.eq", "$eq", "r", "q", "v", "HOL.conj"], "hillel_challenge.sum": ["fc", "int.Sum.sum", "$eq"], "hillel_challenge.diff": ["length$nat", "mach.int.Int32.int32'int", "int.Abs.abs", "$eq", "nat$take", "sum", "$minus", "nat$drop", "Int.nat", "list$sum", "mach.array.Array32.length"], "hillel_challenge.mem": ["$le", "nat$nth", "HOL.conj", "HOL.eq", "HOL.Ex", "$eq", "$lt", "Int.nat"], "my_bag.infix_eqeq": ["HOL.eq", "HOL.All", "$eq"], "sudoku.valid_chunk_up_to": ["$le", "nat$nth", "HOL.All", "HOL.eq", "HOL.implies", "$eq", "HOL.Let", "$lt", "HOL.Not", "Int.nat", "HOL.conj", "$plus"], "sudoku.valid_up_to": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "Grid.valid_row", "$lt", "Grid.valid_column", "HOL.conj", "Grid.valid_square"], "sudoku.full_up_to": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$lt", "HOL.conj"], "inverse_in_place.prefix_tl": ["$minus", "$uminus", "$eq"], "inverse_in_place.numof": ["fc", "int.NumOf.numof", "$eq"], "inverse_in_place.is_permutation": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$eq", "$lt", "HOL.Not", "Int.nat", "length$nat"], "inverse_in_place.loopinvariant": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$eq", "$lt", "Int.nat", "prefix_tl", "$uminus"], "verifythis_2018_mind_the_gap_1.gap_buffer'eq": ["HOL.eq", "l", "$eq", "r", "HOL.conj", "content", "a"], "insertion_sort_list.sorted": ["le", "list.List.Cons"], "sudoku.is_index": ["HOL.eq", "$lt", "HOL.conj", "$le"], "sudoku.valid_values": ["$le", "HOL.All", "is_index", "HOL.implies", "HOL.eq", "HOL.conj"], "sudoku.grid_eq_sub": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "$lt", "HOL.conj"], "hashtbl_impl.in_data": ["nat$nth", "List.set", "bucket", "HOL.eq", "Int.int", "Set.member", "Int.nat", "length$nat"], "hashtbl_impl.good_data": ["in_data", "HOL.eq", "option.Option.Some", "$eq"], "hashtbl_impl.good_hash": ["nat$nth", "List.set", "HOL.All", "bucket", "HOL.implies", "HOL.eq", "Int.int", "$eq", "Set.member", "Int.nat", "length$nat"], "hashtbl_impl.t'eq": ["HOL.eq", "data", "$eq", "HOL.conj", "size", "view"], "sudoku.chunk_valid_indexes": ["$le", "nat$nth", "HOL.All", "HOL.conj", "is_index", "HOL.eq", "Int.int", "HOL.implies", "$eq", "$lt", "Int.nat", "$plus", "length$nat"], "sudoku.disjoint_chunks": ["$le", "nat$nth", "HOL.All", "HOL.conj", "is_index", "HOL.eq", "Int.int", "HOL.implies", "$eq", "HOL.Let", "$lt", "HOL.Not", "Int.nat", "$plus", "length$nat"], "isqrt.sqr": ["$times", "$eq"], "sudoku.well_formed_sudoku": ["row_offsets", "column_offsets", "disjoint_chunks", "square_start", "HOL.eq", "square_offsets", "chunk_valid_indexes", "HOL.conj", "column_start", "row_start"], "sudoku.valid_chunk": ["$le", "nat$nth", "HOL.All", "HOL.eq", "HOL.implies", "$eq", "HOL.Let", "$lt", "HOL.Not", "Int.nat", "HOL.conj", "$plus"], "sudoku.valid_column": ["valid_chunk", "HOL.eq", "column_start", "column_offsets"], "linear_probing.neq": ["HOL.eq", "eq", "HOL.Not"], "sudoku.valid_row": ["valid_chunk", "HOL.eq", "row_offsets", "row_start"], "linear_probing.between": ["$le", "HOL.eq", "HOL.disj", "$lt", "HOL.conj"], "sudoku.valid_square": ["valid_chunk", "HOL.eq", "square_start", "square_offsets"], "linear_probing.numof": ["fc", "int.NumOf.numof", "$eq"], "sudoku.valid": ["HOL.All", "is_index", "HOL.implies", "HOL.eq", "valid_square", "valid_column", "HOL.conj", "valid_row"], "linear_probing.valid": ["nat$nth", "between", "neq", "length$nat", "$le", "HOL.All", "keym1", "$eq", "HOL.Let", "Int.nat", "eq", "HOL.implies", "Int.int", "bucket", "HOL.eq", "why3.Bool.Bool.True", "HOL.Not", "$lt", "dummy", "HOL.conj"], "sudoku.full": ["$le", "HOL.All", "is_index", "HOL.implies", "HOL.eq", "HOL.conj"], "linear_probing.t'eq": ["HOL.eq", "data", "$eq", "loc", "HOL.conj", "size", "view"], "sudoku.included": ["$le", "HOL.All", "is_index", "HOL.implies", "HOL.eq", "$eq", "HOL.conj"], "linear_probing.next": ["$plus", "$eq", "HOL.Let", "HOL.If"], "coincidence_count_list.sorted": ["$lt", "rel", "list.List.Cons"], "arm.inv": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.implies", "$eq", "$lt", "Int.nat", "a", "$plus", "length$nat"], "arm.separation": ["HOL.eq", "$lt", "$minus", "a", "$plus"], "arm.inv_l2": ["$le", "HOL.eq", "$eq", "$minus", "HOL.conj", "inv"], "snapshotable_trees.itree'eq": ["tree", "$eq", "HOL.eq"], "tower_of_hanoi.tower'eq": ["HOL.eq", "rod", "$eq"], "snapshotable_trees.elements": ["MyEnum.enum_elements", "$eq", "it"], "snapshotable_trees.hasNext": ["HOL.eq", "$eq", "HOL.Not", "MyEnum.Done", "it"], "tower_of_hanoi.sorted": ["$lt", "list.List.Cons"], "tower_of_hanoi.sorted1": ["$lt", "list.List.Cons"], "tower_of_hanoi.compat": ["HOL.True", "$lt", "HOL.eq"], "counting_sort.k_values": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$lt", "k", "Int.nat", "length$nat"], "counting_sort.numeq": ["fc", "int.NumOf.numof", "$eq"], "counting_sort.numlt": ["int.NumOf.numof", "$eq", "fc1"], "cursor_examples.cursor'eq": ["HOL.eq", "collection", "$eq", "to_visit", "visited", "HOL.conj", "index"], "cursor_examples.permitted": ["$le", "nat$nth", "HOL.All", "HOL.conj", "collection", "HOL.eq", "HOL.implies", "Int.int", "$eq", "visited", "$lt", "Int.nat", "length$nat"], "cursor_examples.complete": ["HOL.eq", "collection", "$eq", "visited", "length$nat"], "min_max.is_min": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.Ex", "HOL.implies", "$eq", "$lt", "Int.nat", "length$nat"], "min_max.is_max": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.Ex", "HOL.implies", "$eq", "$lt", "Int.nat", "length$nat"], "verifythis_2016_tree_traversal.is_tree": ["Memory.null", "HOL.eq", "Memory.Left", "$eq", "HOL.Let", "HOL.Not", "Memory.Right", "HOL.conj", "Memory.Parent"], "snapshotable_trees.lt_tree": ["HOL.All", "HOL.implies", "HOL.eq", "$lt", "Tree.mem"], "verifythis_2016_tree_traversal.footprint": ["set.Set.add", "set.Set.empty", "set.Set.union", "$eq"], "snapshotable_trees.gt_tree": ["HOL.All", "HOL.implies", "HOL.eq", "$lt", "Tree.mem"], "snapshotable_trees.bst": ["HOL.eq", "HOL.True", "gt_tree", "HOL.conj", "lt_tree"], "verifythis_2016_tree_traversal.ext": ["HOL.All", "HOL.implies", "HOL.eq", "$eq", "set.Set.mem"], "verifythis_2016_tree_traversal.unchanged": ["HOL.eq", "HOL.All", "$eq"], "verifythis_2016_tree_traversal.was_marked": ["footprint", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "why3.Bool.Bool.True", "HOL.Not", "HOL.conj", "set.Set.mem"], "knuth_prime_numbers.no_prime_in": ["HOL.All", "HOL.implies", "HOL.eq", "$lt", "HOL.Not", "HOL.conj", "number.Prime.prime"], "knuth_prime_numbers.first_primes": ["$le", "HOL.All", "HOL.implies", "no_prime_in", "HOL.eq", "$eq", "$lt", "$minus", "HOL.conj", "$plus", "number.Prime.prime"], "snapshotable_trees.enum_elements": ["$append", "$eq", "list.List.Cons", "list.List.Nil", "Tree.tree_elements"], "decrease1.decrease1": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$lt", "$minus", "Int.nat", "$plus", "length$nat"], "verifythis_2016_tree_traversal.frame_memo": ["$le", "memo0", "HOL.If", "memo4", "$eq", "memo1", "memo2", "memo3"], "verifythis_2016_tree_traversal.bloc_rel": ["HOL.All", "HOL.If", "Memory.null", "HOL.eq", "HOL.implies", "parent", "Memory.Left", "$eq", "cursor", "marks", "pointers", "why3.Bool.Bool.True", "HOL.Not", "TreeShape.rotated", "TreeShape.next_phase", "Memory.Right", "HOL.conj", "Memory.Parent"], "verifythis_2016_tree_traversal.rec_rel": ["TreeShape.was_marked", "HOL.eq", "parent", "$eq", "cursor", "marks", "pointers", "TreeShape.unchanged", "HOL.conj"], "verifythis_2016_tree_traversal.is_stack": ["Memory.null", "option.Option.None", "memo4", "TreeShape.GoRight", "bintree.Tree.Node", "memo3", "$le", "parent", "$eq", "HOL.Let", "rec_rel", "pleft", "Memory.Right", "memo2", "memo0", "HOL.implies", "cursor", "pointers", "bloc_rel", "pright", "TreeShape.GoLeft", "HOL.If", "HOL.eq", "tree", "Memory.Left", "frame_memo", "TreeShape.is_tree", "tright", "HOL.Not", "memo1", "tleft", "HOL.conj", "option.Option.Some"], "verifythis_2016_tree_traversal.stack_size": ["$le", "HOL.If", "$times", "$eq", "tright", "$minus", "tleft", "bintree.Size.size", "$plus"], "dfa_example.mem": ["Star"], "verifythis_PrefixSumRec.is_power_of_2": ["$le", "HOL.eq", "HOL.Ex", "int.Power.power", "$eq", "HOL.conj"], "verifythis_PrefixSumRec.go_left": ["$minus", "$eq", "HOL.Let", "int.ComputerDivision.div"], "verifythis_PrefixSumRec.go_right": ["$minus", "$eq", "HOL.Let", "int.ComputerDivision.div"], "verifythis_PrefixSumRec.phase1": ["nat$nth", "$plus", "go_left", "$eq", "go_right", "nat$take", "$lt", "$minus", "nat$drop", "Int.nat", "list$sum"], "verifythis_PrefixSumRec.partial_sum": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$eq", "nat$take", "$lt", "$minus", "nat$drop", "Int.nat", "list$sum"], "dfs.edge": ["right1", "HOL.eq", "HOL.disj", "$eq", "null", "HOL.Not", "left1", "HOL.conj"], "dfs.path": ["edge"], "dfs.only_descendants_are_marked": ["HOL.All", "HOL.implies", "HOL.eq", "$eq", "why3.Bool.Bool.True", "null", "HOL.Not", "HOL.conj", "root", "path"], "dfs.well_colored": ["HOL.All", "HOL.implies", "HOL.eq", "HOL.disj", "$eq", "why3.Bool.Bool.True", "null", "HOL.Not", "edge"], "dfs.all_descendants_are_marked": ["HOL.All", "HOL.implies", "HOL.eq", "$eq", "why3.Bool.Bool.True", "null", "HOL.Not", "edge", "HOL.conj", "root"], "flag2.monochrome": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "$lt", "HOL.conj"], "bresenham.best": ["$le", "HOL.All", "$times", "HOL.eq", "int.Abs.abs", "$minus"], "mccarthy.spec": ["$le", "$minus", "$eq", "HOL.If"], "induction.pr": ["Hyps.p", "$plus", "HOL.conj", "HOL.eq"], "vstte10_search_list.zero_at": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "$lt", "HOL.Not", "HOL.conj", "option.Option.Some", "nth_opt$i"], "vstte10_search_list.no_zero": ["$le", "HOL.All", "HOL.implies", "Int.int", "HOL.eq", "$eq", "$lt", "HOL.Not", "HOL.conj", "option.Option.Some", "nth_opt$i", "length$nat"], "wrap_lines.at_least_line_length": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "HOL.disj", "$eq", "$lt", "$minus", "Int.nat", "$uminus", "newline", "length$nat"], "verifythis_2024_challenge0.to_str": ["$append", "$eq"], "verifythis_2024_challenge0.valid": ["to_str", "HOL.True", "HOL.eq", "Int.int", "$eq", "HOL.conj", "length$nat"], "verifythis_2021_lexicographic_permutations_1.lt": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.Ex", "HOL.implies", "$eq", "$lt", "Int.nat", "length$nat"], "verifythis_2021_lexicographic_permutations_1.occ": ["int.NumOf.numof", "iseq", "$eq"], "verifythis_2021_lexicographic_permutations_1.occ_all": ["Int.int", "occ", "$eq", "length$nat"], "verifythis_2021_lexicographic_permutations_1.is_permutation_of": ["occ_all", "HOL.All", "HOL.eq", "$eq", "HOL.conj", "length$nat"], "verifythis_2021_lexicographic_permutations_1.descending": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.implies", "$lt", "Int.nat", "length$nat"], "verifythis_2021_lexicographic_permutations_1.ascending": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.implies", "$lt", "Int.nat", "length$nat"], "vstte10_aqueue.queue'eq": ["HOL.eq", "rear", "$eq", "front", "lenf", "HOL.conj", "lenr"], "vstte10_aqueue.sequence": ["$append", "list.Reverse.reverse", "rear", "$eq", "front"], "bellman_ford.edge": ["HOL.eq", "set.Fset.mem", "edges"], "bellman_ford.path": ["edge"], "bellman_ford.path_weight": ["weight", "$plus", "$eq"], "bellman_ford.pigeon_set": ["$append", "List.set", "HOL.All", "HOL.implies", "HOL.eq", "HOL.Ex", "$eq", "set.Fset.mem", "FSet$fcard", "$lt", "Set.member", "list.List.Cons", "length$nat"], "bellman_ford.cyc_decomp": ["$append", "HOL.eq", "Int.int", "$eq", "$lt", "path", "HOL.conj", "s", "length$nat"], "string_hex_encoding.valid_hex_char": ["$le", "HOL.eq", "HOL.disj", "$lt", "string.Char.code", "HOL.conj"], "string_hex_encoding.hex": ["$le", "nat$nth", "HOL.If", "$eq", "$lt", "string.Char.chr", "HOL.conj", "$plus"], "bellman_ford.inv1": ["$le", "Graph.weight", "HOL.All", "Graph.path_weight", "Graph.vertices", "HOL.implies", "HOL.eq", "HOL.Ex", "Int.int", "Graph.s", "$eq", "set.Fset.mem", "mixfix_lbrb", "$lt", "Graph.path", "HOL.conj", "$plus", "length$nat"], "bellman_ford.inv2": ["int.IntInf.le", "Graph.weight", "HOL.All", "HOL.implies", "HOL.eq", "int.IntInf.add", "set.Fset.mem", "int.IntInf.Finite", "mixfix_lbrb"], "string_hex_encoding.xeh": ["$le", "HOL.If", "$eq", "$lt", "string.Char.code", "$minus", "HOL.conj", "$uminus"], "string_hex_encoding.valid_hex": ["$le", "nat$nth", "int.ComputerDivision.mod", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.implies", "$eq", "$lt", "Int.nat", "valid_hex_char", "length$nat"], "string_hex_encoding.encoding": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "$times", "HOL.implies", "$eq", "xeh", "$lt", "string.Char.chr", "valid_hex", "Int.nat", "$plus", "length$nat"], "vacid_0_sparse_array.sparse_array'eq": ["card", "back", "def1", "values", "HOL.eq", "$eq", "HOL.conj", "index"], "vacid_0_sparse_array.is_elt": ["card", "$le", "nat$nth", "back", "HOL.conj", "HOL.eq", "$eq", "$lt", "Int.nat", "index"], "vacid_0_sparse_array.value": ["is_elt", "nat$nth", "def1", "values", "HOL.If", "$eq", "Int.nat"], "vacid_0_sparse_array.length": ["values", "Int.int", "$eq", "length$nat"], "lcp.eqseq": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.implies", "$eq", "$lt", "Int.nat", "$plus", "length$nat"], "coincidence_count.setof": ["set.FsetInt.interval", "set.Fset.map", "Int.int", "$eq", "mixfix_lbrb_closure", "length$nat"], "coincidence_count.drop": ["set.FsetInt.interval", "set.Fset.map", "Int.int", "$eq", "mixfix_lbrb_closure", "bagofsub", "length$nat"], "coincidence_count.increasing": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$lt", "Int.nat", "length$nat"], "coincidence_count.cc": ["Int.int", "$eq", "set.Fset.inter", "setof", "FSet$fcard"], "resizable_array.rarray'eq": ["HOL.eq", "data", "$eq", "length", "dummy", "HOL.conj"], "resizable_array.mixfix_lbrb": ["Int.nat", "data", "nat$nth", "$eq"], "coincidence_count.bagof": ["Int.int", "$eq", "bagofsub", "length$nat"], "huffman_with_two_queues.last": ["nat$nth", "Int.int", "$eq", "$minus", "Int.nat", "length$nat"], "string_search.bad_shift_table'eq": ["pat", "HOL.eq", "$eq", "HOL.conj", "sht"], "bellman_ford.negative_cycle": ["HOL.eq", "HOL.Ex", "set.Fset.mem", "$lt", "path", "vertices", "HOL.conj", "path_weight", "s"], "bellman_ford.all_path_gt": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$lt", "path", "vertices", "FSet$fcard", "HOL.conj", "path_weight", "s", "length$nat"], "algo64.qs_partition": ["$le", "nat$nth", "HOL.All", "HOL.eq", "HOL.implies", "$eq", "ArrayPermut$permut_sub", "$lt", "Int.nat", "HOL.conj", "$plus"], "binary_search.f": ["log2", "$plus", "$eq", "HOL.If"], "linked_list_rev.valid_cells": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "null", "$lt", "HOL.Not", "HOL.conj"], "linked_list_rev.listLR": ["$le", "HOL.All", "HOL.If", "next", "HOL.eq", "HOL.implies", "$eq", "null", "$lt", "$minus", "HOL.conj", "$plus"], "linked_list_rev.listRL": ["$le", "HOL.All", "HOL.If", "next", "HOL.eq", "HOL.implies", "$eq", "null", "$lt", "$minus", "HOL.conj"], "linked_list_rev.frame": ["$le", "HOL.All", "next", "HOL.implies", "HOL.eq", "$eq", "$lt", "HOL.Not", "HOL.conj"], "search.path": ["$le", "Int.int", "$lt", "moves", "length$nat"], "search.move": ["$le", "nat$nth", "HOL.conj", "HOL.eq", "Int.int", "HOL.Ex", "$eq", "$lt", "Int.nat", "moves", "length$nat"], "mex.mem": ["$le", "nat$nth", "HOL.conj", "HOL.eq", "Int.int", "HOL.Ex", "$eq", "$lt", "Int.nat", "length$nat"], "swap.int32'eq": ["int32'int", "HOL.eq", "$eq"], "swap.in_bounds": ["$le", "HOL.eq", "int32'int", "HOL.conj", "$uminus"], "quicksort.qs_partition": ["$le", "nat$nth", "HOL.All", "HOL.eq", "HOL.implies", "$eq", "ArrayPermut$permut_sub", "$lt", "Int.nat", "HOL.conj"], "binomial_heap.size": ["$plus", "$eq"], "linked_list_rev.disjoint": ["$le", "nat$nth", "List.set", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$eq", "$lt", "HOL.Not", "Set.member", "Int.nat", "length$nat"], "binomial_heap.le_roots": ["HOL.eq", "HOL.True", "le", "HOL.conj", "elem"], "linked_list_rev.no_repet": ["$le", "nat$nth", "List.set", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "HOL.True", "$lt", "HOL.Not", "Set.member", "nat$drop", "Int.nat", "$plus", "length$nat"], "linked_list_rev.list_seg": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.implies", "HOL.disj", "$eq", "HOL.Let", "null", "$lt", "HOL.Not", "$minus", "Int.nat", "$plus", "length$nat"], "find.found": ["$le", "nat$nth", "x_N", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.nat", "f"], "find.m_invariant": ["$le", "nat$nth", "x_N", "HOL.All", "HOL.conj", "HOL.eq", "HOL.implies", "$lt", "Int.nat", "f"], "find.n_invariant": ["$le", "nat$nth", "x_N", "HOL.All", "HOL.conj", "HOL.eq", "HOL.implies", "$lt", "Int.nat", "f"], "find.i_invariant": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$lt", "Int.nat"], "find.j_invariant": ["$le", "nat$nth", "x_N", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$lt", "Int.nat"], "find.termination": ["$le", "nat$nth", "HOL.conj", "HOL.eq", "HOL.disj", "$eq", "$lt", "Int.nat", "f"], "binomial_heap.heaps": ["HOL.eq", "HOL.True", "HOL.conj", "le_roots"], "binomial_heap.occ": ["$plus", "$eq", "HOL.If"], "binomial_heap.mem": ["HOL.eq", "$lt", "occ"], "binomial_heap.has_order": ["HOL.eq", "$minus", "HOL.conj", "$eq"], "binomial_heap.binomial_tree": ["children", "rank", "HOL.eq", "Int.int", "$eq", "has_order", "HOL.conj", "length$nat"], "binomial_heap.inv": ["$le", "binomial_tree", "rank", "HOL.True", "HOL.eq", "HOL.Let", "HOL.conj", "$plus"], "verifythis_2018_le_rouge_et_le_noir_2.bijection": ["HOL.All", "HOL.implies", "HOL.eq", "$eq", "why3.Bool.Bool.True", "set.Fset.mem", "HOL.conj"], "verifythis_2018_le_rouge_et_le_noir_2.cardinal'eq": ["card", "HOL.eq", "cset", "$eq", "HOL.conj"], "braun_trees.le_root": ["HOL.eq", "HOL.True", "le"], "braun_trees.heap": ["HOL.eq", "HOL.True", "le_root", "HOL.conj"], "braun_trees.is_minimum": ["bintree.Occ.mem", "HOL.All", "HOL.implies", "HOL.eq", "le", "HOL.conj"], "braun_trees.inv": ["HOL.eq", "HOL.True", "HOL.disj", "$eq", "HOL.conj", "bintree.Size.size", "$plus"], "bignum.value": ["$plus", "$times", "base", "$eq"], "bignum.valid": ["$le", "HOL.True", "HOL.eq", "$lt", "HOL.conj", "base"], "skew_heaps.sorted_sub": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "SkewHeaps.le", "$lt", "Int.nat"], "skew_heaps.sorted": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "SkewHeaps.le", "$lt", "Int.nat", "length$nat"], "verifythis_2018_le_rouge_et_le_noir_2.red": ["seq.Seq.create", "$eq", "fc"], "verifythis_2018_le_rouge_et_le_noir_2.valid_coloring_f": ["$le", "Black"], "verifythis_2018_le_rouge_et_le_noir_2.valid_coloring": ["Red", "HOL.eq", "HOL.disj", "valid_coloring_f", "Black"], "verifythis_2018_le_rouge_et_le_noir_2.valid_coloring_l": ["HOL.eq", "Int.int", "$eq", "HOL.conj", "valid_coloring", "length$nat"], "verifythis_2018_le_rouge_et_le_noir_2.valid_coloring_inter": ["$le", "nat$nth", "HOL.conj", "HOL.eq", "HOL.Ex", "$eq", "$lt", "valid_coloring_l", "Black", "Int.nat"], "verifythis_2018_le_rouge_et_le_noir_2.valid_coloring_at": ["$le", "nat$nth", "HOL.All", "HOL.conj", "Red", "HOL.eq", "HOL.implies", "$eq", "$lt", "valid_coloring_l", "Black", "Int.nat"], "skew_heaps.le_root": ["HOL.eq", "HOL.True", "le"], "skew_heaps.heap": ["HOL.eq", "HOL.True", "le_root", "HOL.conj"], "skew_heaps.is_minimum": ["bintree.Occ.mem", "HOL.All", "mem", "HOL.implies", "HOL.eq", "le", "HOL.conj"], "binomial_heap.link": ["children", "rank", "HOL.If", "$eq", "le", "list.List.Cons", "tree'mk", "$plus", "elem"], "unraveling_a_card_trick.shuffle": [], "space_saving.occurs": ["$le", "nat$nth", "HOL.conj", "HOL.eq", "Int.int", "HOL.Ex", "$eq", "$lt", "Int.nat", "length$nat"], "skew_heaps.mem": ["HOL.eq", "$lt", "occ"], "verifythis_2024_challenge1.permutation": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.implies", "$eq", "$lt", "HOL.Not", "Int.nat", "length$nat"], "verifythis_2024_challenge1.permutation_pair": ["$le", "nat$nth", "permutation", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$eq", "$lt", "Int.nat"], "verifythis_2024_challenge1.valid_chunk": ["$le", "HOL.eq", "Int.int", "HOL.conj", "$plus", "length$nat"], "verifythis_2024_challenge1.copy": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$eq", "$lt", "valid_chunk", "Int.nat", "$plus", "length$nat"], "verifythis_2024_challenge1.copy_to": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$eq", "$lt", "$minus", "valid_chunk", "Int.nat", "$plus", "length$nat"], "verifythis_2024_challenge1.copy_perm": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$eq", "$lt", "permutation_pair", "valid_chunk", "Int.nat", "length$nat"], "verifythis_2024_challenge1.copy_subsegment": ["$le", "nat$nth", "HOL.All", "HOL.eq", "$times", "HOL.implies", "$eq", "HOL.Let", "$lt", "Int.nat", "copy_to", "HOL.conj", "$plus"], "verifythis_2024_challenge1.frame": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$eq", "$lt", "Int.nat", "$plus", "length$nat"], "tortoise_and_hare.x": ["x0", "f_closure", "$eq", "int.Iter.iter"], "linked_list_rev.inside_memory": ["$le", "HOL.eq", "HOL.Ex", "HOL.disj", "$eq", "null", "$lt", "HOL.conj"], "linked_list_rev.finite_memory": ["$le", "HOL.All", "next", "HOL.implies", "HOL.eq", "$lt", "inside_memory", "HOL.conj"], "linked_list_rev.seen": ["fc", "int.NumOf.numof", "$eq"], "just_join.ht": ["$eq"], "just_join.node": ["$eq", "ht", "N", "int.MinMax.max", "$plus"], "just_join.height": ["int.MinMax.max", "$plus", "$eq"], "just_join.wf": ["HOL.eq", "HOL.True", "$eq", "height", "HOL.conj"], "just_join.mem": ["HOL.eq", "HOL.disj", "HOL.False", "$eq"], "just_join.tree_lt": ["HOL.All", "mem", "HOL.implies", "HOL.eq", "lt"], "just_join.lt_tree": ["HOL.All", "mem", "HOL.implies", "HOL.eq", "lt"], "just_join.bst": ["tree_lt", "HOL.eq", "HOL.True", "HOL.conj", "lt_tree"], "just_join.avl": ["$le", "HOL.True", "HOL.eq", "$minus", "height", "HOL.conj", "$uminus"], "koda_ruskey.mem_stack": ["HOL.eq", "HOL.disj", "HOL.False", "KodaRuskey_Spec.mem_forest"], "koda_ruskey.size_stack": ["$plus", "KodaRuskey_Spec.size_forest", "$eq"], "koda_ruskey.even_forest": ["HOL.eq", "HOL.Not", "HOL.disj", "HOL.False"], "koda_ruskey.final_forest": ["HOL.If", "HOL.eq", "HOL.True", "KodaRuskey_Spec.white_forest", "$eq", "even_forest", "KodaRuskey_Spec.Black", "HOL.Not", "HOL.conj"], "koda_ruskey.any_forest": ["final_forest", "HOL.eq", "HOL.disj", "KodaRuskey_Spec.white_forest"], "koda_ruskey.unchanged": ["mem_stack", "HOL.All", "HOL.implies", "HOL.eq", "$eq"], "koda_ruskey.inverse": ["unchanged", "HOL.If", "HOL.eq", "HOL.True", "HOL.disj", "KodaRuskey_Spec.white_forest", "even_forest", "final_forest", "HOL.conj"], "koda_ruskey.any_stack": ["HOL.eq", "HOL.True", "HOL.disj", "KodaRuskey_Spec.white_forest", "final_forest", "HOL.conj"], "koda_ruskey.sub": ["KodaRuskey_Spec.Black", "$eq"], "koda_ruskey.disjoint_stack": ["mem_stack", "HOL.All", "HOL.implies", "HOL.eq", "HOL.Not", "KodaRuskey_Spec.mem_forest"], "euler011.left_diag": ["$le", "HOL.If", "option.Option.None", "$times", "$eq", "matrix.Matrix.rows", "$lt", "$minus", "matrix.Matrix.columns", "HOL.conj", "matrix.Matrix.elts", "$plus", "option.Option.Some"], "euler011.right_diag": ["$le", "HOL.If", "option.Option.None", "$times", "$eq", "matrix.Matrix.rows", "$lt", "$minus", "matrix.Matrix.columns", "HOL.conj", "matrix.Matrix.elts", "$plus", "option.Option.Some"], "euler011.line": ["$le", "HOL.If", "option.Option.None", "$times", "$eq", "matrix.Matrix.rows", "$lt", "matrix.Matrix.columns", "$minus", "HOL.conj", "matrix.Matrix.elts", "$plus", "option.Option.Some"], "euler011.column": ["$le", "HOL.If", "option.Option.None", "$times", "$eq", "matrix.Matrix.rows", "$lt", "$minus", "matrix.Matrix.columns", "HOL.conj", "matrix.Matrix.elts", "$plus", "option.Option.Some"], "euler011.compute4": ["Right_bottom", "line", "option.Option.None", "Bottom", "HOL.If", "Left_bottom", "$eq", "right_diag", "column", "left_diag", "Right"], "verifythis_2019_ghc_sort.sorted": ["$lt", "list.List.Cons"], "verifythis_2019_ghc_sort.sorted1": ["$le", "list.List.Cons"], "verifythis_2019_ghc_sort.sorted2": ["$le", "list.List.Cons"], "verifythis_2019_ghc_sort.compat": ["HOL.eq", "HOL.True", "$le"], "verifythis_2019_ghc_sort.eqb": ["bool.Bool.andb", "bool.Bool.implb", "$eq"], "verifythis_2019_ghc_sort.list_seq'eq": ["HOL.eq", "seq", "$eq", "list", "HOL.conj"], "koda_ruskey.count_stack": ["$times", "$eq", "KodaRuskey_Spec.count_forest"], "koda_ruskey.stored_solutions": ["KodaRuskey_Spec.eq_coloring", "nat$nth", "length$nat", "$le", "mem_stack", "HOL.All", "$eq", "HOL.Let", "$minus", "Int.nat", "KodaRuskey_Spec.size_forest", "HOL.implies", "Int.int", "count_stack", "HOL.eq", "KodaRuskey_Spec.valid_coloring", "$lt", "HOL.Not", "HOL.conj"], "vstte12_combinators.eq": ["HOL.eq", "HOL.True", "HOL.False", "HOL.conj"], "vstte12_combinators.is_value": ["HOL.eq", "HOL.True", "HOL.False", "HOL.conj"], "vstte12_combinators.is_context": ["HOL.eq", "HOL.True", "is_value", "HOL.conj"], "vstte12_combinators.subst": ["App", "$eq"], "vstte12_combinators.infix_mnmngt": ["is_value", "is_context"], "vstte12_combinators.relTR": ["infix_mnmngt"], "vstte12_combinators.subst_c": ["Left", "Right", "$eq"], "locate_max.mixfix_lbrb": ["nat$nth", "$eq", "mach.c.C.data", "$comp", "mach.c.C.offset", "Int.nat", "$plus"], "dijkstra.min": ["$le", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "to_fset", "set.Fset.mem", "mixfix_lbrb"], "dijkstra.path": ["g_succ", "set.Fset.mem"], "dijkstra.shortest_path": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "HOL.conj", "path"], "vstte12_combinators.irreducible": ["HOL.eq", "HOL.Not", "HOL.All", "infix_mnmngt"], "vstte12_combinators.only_K": [], "dijkstra.inv_src": ["HOL.eq", "set.Fset.mem", "HOL.disj", "to_fset"], "dijkstra.inv": ["HOL.All", "shortest_path", "HOL.implies", "HOL.eq", "mixfix_lbrb", "$eq", "to_fset", "set.Fset.mem", "HOL.Not", "v", "inv_src", "HOL.conj", "set.Fset.subset", "path"], "dijkstra.inv_succ": ["$le", "weight", "HOL.All", "g_succ", "HOL.conj", "HOL.implies", "HOL.eq", "HOL.disj", "to_fset", "set.Fset.mem", "mixfix_lbrb", "$plus"], "dijkstra.inv_succ2": ["$le", "weight", "HOL.All", "g_succ", "HOL.conj", "HOL.implies", "HOL.eq", "HOL.disj", "$eq", "to_fset", "set.Fset.mem", "HOL.Not", "mixfix_lbrb", "$plus"], "fill.contains": ["HOL.eq", "HOL.disj", "HOL.False", "$eq"], "f_puzzle.p'": ["$le", "HOL.All", "Puzzle.f", "HOL.implies", "HOL.eq", "HOL.conj"], "queens_bv.t'eq": ["bv", "HOL.eq", "$eq", "HOL.conj", "mdl"], "f_puzzle.p": ["$le", "HOL.All", "Puzzle.f", "HOL.implies", "HOL.eq", "$plus"], "fenwick.valid": ["$le", "nat$nth", "length$nat", "HOL.All", "HOL.conj", "HOL.If", "HOL.eq", "Int.int", "$times", "HOL.implies", "$eq", "leaves", "$lt", "$minus", "Int.nat", "$plus", "t"], "fenwick.get": ["nat$nth", "$eq", "leaves", "$minus", "Int.nat", "$plus", "t"], "queens_bv.eq_prefix": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "$lt", "HOL.conj"], "fenwick.rget": ["int.Sum.sum", "$eq", "get_closure"], "queens_bv.partial_solution": ["$le", "n", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "$lt", "HOL.Not", "$minus", "HOL.conj"], "queens_bv.lt_sol": ["$le", "n", "HOL.eq", "HOL.Ex", "$lt", "eq_prefix", "HOL.conj"], "queens_bv.sorted": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$lt", "HOL.conj", "lt_sol"], "string_base64_encoding.int2b64": ["$le", "HOL.If", "$eq", "string.Char.chr", "$minus", "HOL.conj", "$plus"], "i_cant_believe_it_can_sort.sorted_sub": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$lt", "le", "Int.nat"], "i_cant_believe_it_can_sort.sorted": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$lt", "le", "Int.nat", "length$nat"], "i_cant_believe_it_can_sort.max_array": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$lt", "le", "Int.nat"], "string_base64_encoding.valid_b64_char": ["$le", "HOL.eq", "HOL.disj", "$eq", "string.Char.code", "HOL.conj"], "string_base64_encoding.b642int": ["$le", "HOL.If", "$eq", "string.Char.code", "$minus", "string.Char.chr", "HOL.conj", "$plus", "mach.int.Int63.int63'int"], "string_base64_encoding.get_pad": ["$le", "nat$nth", "HOL.conj", "HOL.If", "Int.int", "$eq", "$minus", "string.Char.chr", "Int.nat", "mach.int.Int63.int63'int", "length$nat"], "string_base64_encoding.calc_pad": ["int.ComputerDivision.mod", "HOL.If", "Int.int", "$eq", "length$nat"], "string_base64_encoding.encoding": ["nat$nth", "int.ComputerDivision.mod", "int.ComputerDivision.div", "length$nat", "$le", "HOL.All", "$times", "$eq", "calc_pad", "$minus", "Int.nat", "mach.int.Int63.int63'int", "get_pad", "HOL.implies", "Int.int", "valid_b64_char", "HOL.eq", "b642int", "$lt", "string.Char.chr", "HOL.conj", "$plus"], "string_base64_encoding.valid_b64": ["$le", "nat$nth", "get_pad", "int.ComputerDivision.mod", "HOL.All", "HOL.conj", "length$nat", "HOL.eq", "Int.int", "HOL.implies", "b642int", "$eq", "$lt", "$minus", "string.Char.chr", "Int.nat", "mach.int.Int63.int63'int", "valid_b64_char"], "insertion_sort.sorted_sub": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$lt", "le", "HOL.conj"], "insertion_sort.sorted_sub1": ["nat$nth", "HOL.eq", "$comp", "sorted_sub", "Int.nat"], "insertion_sort.sorted": ["nat$nth", "HOL.eq", "Int.int", "$comp", "sorted_sub", "Int.nat", "length$nat"], "insertion_sort_naive.sorted_sub": ["$le", "nat$nth", "HOL.All", "HOL.implies", "HOL.eq", "$lt", "Int.nat", "le", "HOL.conj"], "insertion_sort_naive.sorted": ["nat$nth", "HOL.eq", "Int.int", "$comp", "sorted_sub", "Int.nat", "length$nat"], "defunctionalization.eval_0": ["$le", "HOL.If", "$eq", "Vnum", "Underflow", "$minus"], "defunctionalization.eval_1": ["$le", "fc1", "HOL.If", "$eq", "Vnum", "Underflow"], "defunctionalization.interpret_1": ["identity", "$eq", "eval_1"], "koda_ruskey.size_forest": ["$plus", "$eq"], "koda_ruskey.mem_forest": ["HOL.eq", "HOL.disj", "HOL.False", "$eq"], "koda_ruskey.between_range_forest": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$lt", "HOL.conj", "mem_forest"], "koda_ruskey.disjoint": ["HOL.All", "HOL.implies", "HOL.eq", "HOL.Not", "mem_forest"], "koda_ruskey.no_repeated_forest": ["HOL.eq", "HOL.True", "HOL.Not", "HOL.conj", "mem_forest", "disjoint"], "koda_ruskey.valid_nums_forest": ["HOL.eq", "no_repeated_forest", "HOL.conj", "between_range_forest"], "koda_ruskey.white_forest": ["HOL.eq", "HOL.True", "$eq", "HOL.conj", "White"], "koda_ruskey.valid_coloring": ["HOL.eq", "HOL.True", "white_forest", "HOL.conj"], "koda_ruskey.count_forest": ["$times", "$plus", "$eq"], "insertion_sort_naive.sorted_sub1": ["nat$nth", "HOL.eq", "$comp", "sorted_sub", "Int.nat"], "verifythis_2019_cartesian_trees.sorted": ["$le", "list.List.Cons"], "verifythis_2019_cartesian_trees.parent": ["nat$nth", "right1", "HOL.eq", "HOL.disj", "$eq", "left1", "Int.nat", "option.Option.Some"], "verifythis_2019_cartesian_trees.descendant": ["nat$nth", "right1", "$eq", "left1", "Int.nat", "option.Option.Some"], "verifythis_2019_cartesian_trees.is_smallest": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.implies", "$lt", "Int.nat", "length$nat"], "defunctionalization.eval_cont": ["$le", "HOL.If", "B", "Vnum", "Underflow", "$minus", "DirectSem.eval_0", "eval_0", "A2"], "defunctionalization.size_e": ["S", "$plus", "$eq"], "defunctionalization.size_c": ["S", "size_e", "Defunctionalization.size_e", "$eq", "$plus"], "there_and_back_again.pal": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "$lt", "$minus", "HOL.conj", "nth_opt$i"], "defunctionalization.is_a_redex": ["HOL.eq", "HOL.True", "HOL.False"], "defunctionalization.recompose": ["Expr.Cte", "$eq", "Expr.Sub"], "defunctionalization.is_a_value": ["HOL.eq", "HOL.True", "HOL.False"], "defunctionalization.is_empty_context": ["HOL.eq", "HOL.True", "HOL.False"], "euler002.fib_even": ["int.Fibonacci.fib", "$times", "$eq"], "mergesort_list.sorted": ["le", "list.List.Cons"], "verifythis_2018_register_allocation.no_collision": ["to_fmap", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "$fmlookup", "set.Fset.mem", "to_fset", "HOL.Not", "fmap.Fmap.domain", "$the"], "verifythis_2018_register_allocation.irrefl": ["to_fmap", "HOL.All", "HOL.implies", "HOL.eq", "$fmlookup", "set.Fset.mem", "to_fset", "HOL.Not", "fmap.Fmap.domain", "$the"], "verifythis_2018_register_allocation.sym": ["to_fmap", "HOL.All", "HOL.implies", "HOL.eq", "$fmlookup", "set.Fset.mem", "to_fset", "fmap.Fmap.domain", "$the"], "verifythis_2017_odd_even_sort_rearranging.aux": ["$times", "$minus", "$eq"], "verifythis_2017_odd_even_sort_rearranging.entropy": ["nat$nth", "aux_closure", "Int.int", "int.Sum.sum", "$eq", "$comp", "Int.nat", "length$nat"], "finite_tarski.fixpoint": ["HOL.conj", "HOL.eq", "$eq", "set.Fset.mem", "f", "a"], "verifythis_2015_parallel_gcd.inv": ["$le", "local_a", "HOL.True", "HOL.eq", "HOL.implies", "$eq", "state1", "$lt", "number.Gcd.gcd", "HOL.conj", "local_b"], "verifythis_2015_parallel_gcd.progress_thread": ["Halt", "HOL.eq", "HOL.disj", "$eq", "$lt", "HOL.Not", "HOL.conj", "state1"], "verifythis_2015_parallel_gcd.state_index": ["$eq"], "verifythis_2015_parallel_gcd.sync": ["HOL.True", "HOL.eq", "$eq", "state1", "local_b"], "verifythis_2015_parallel_gcd.sync_index": ["sync", "$eq", "HOL.If"], "verifythis_2015_parallel_gcd.prog_index": ["state1", "$eq", "sync_index", "state_index", "$plus"], "euler001.closed_formula_aux": ["int.ComputerDivision.div", "$times", "TriangularNumbers.tr", "HOL.Let", "$eq", "$minus", "$plus"], "euler001.p": ["sum_multiple_3_5_lt", "HOL.eq", "$eq", "closed_formula_aux", "$plus"], "verifythis_2019_cartesian_trees.sorted1": ["$lt", "list.List.Cons"], "defunctionalization.eval_2": ["$le", "HOL.If", "eval_2a", "$eq"], "defunctionalization.interpret_2": ["eval_2", "Vnum_closure", "$eq", "fc2"], "euler001.closed_formula": ["int.ComputerDivision.div", "$times", "$eq", "HOL.Let", "$minus", "$plus"], "defunctionalization.eval_3": ["eval_3a", "$le", "HOL.If", "$eq", "Underflow"], "defunctionalization.interpret_3": ["Vnum_closure", "$eq", "eval_3"], "euler001.tr": ["$times", "$plus", "$eq", "int.ComputerDivision.div"], "generate_all_trees.size": ["$plus", "$eq"], "generate_all_trees.all_trees": ["List.set", "HOL.All", "list.Distinct.distinct", "HOL.eq", "$eq", "Set.member", "HOL.conj", "size"], "sieve.no_factor_lt": ["HOL.All", "HOL.implies", "$times", "HOL.eq", "$eq", "$lt", "HOL.Not", "HOL.conj"], "subsequence.subsequence": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$eq", "$lt", "Int.nat", "length$nat"], "verifythis_2018_le_rouge_et_le_noir_1.tworedneighbors": ["$le", "nat$nth", "HOL.conj", "Red", "HOL.eq", "Int.int", "HOL.disj", "$eq", "$minus", "Int.nat", "$plus", "length$nat"], "verifythis_2018_le_rouge_et_le_noir_1.valid": ["$le", "nat$nth", "HOL.All", "HOL.conj", "Red", "HOL.implies", "HOL.eq", "Int.int", "tworedneighbors", "$eq", "$lt", "Int.nat", "length$nat"], "ring_buffer.t'eq": ["n", "HOL.eq", "data", "$eq", "m", "contents", "HOL.conj"], "vstte10_queens.eq_board": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$eq", "$lt", "Int.nat"], "vstte10_queens.consistent_row": ["nat$nth", "HOL.conj", "HOL.eq", "$eq", "HOL.Not", "$minus", "Int.nat"], "vstte10_queens.is_consistent": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "consistent_row", "$lt", "HOL.conj"], "vstte10_queens.is_board": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "mach.array.Array63.elts", "$lt", "mach.array.Array63.length", "Int.nat", "mach.int.Int63.int63'int", "length$nat"], "vstte10_queens.solution": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$lt", "is_consistent", "HOL.conj", "is_board"], "mccarthy_vc_sp.spec": ["$le", "$minus", "$eq", "HOL.If"], "verifythis_2018_le_rouge_et_le_noir_1.mapaddleft": ["set.Fset.map", "$eq", "addleft_closure"], "verifythis_2018_le_rouge_et_le_noir_1.reciprocal": ["HOL.eq", "HOL.All", "$eq"], "verifythis_2018_le_rouge_et_le_noir_1.rmleft": ["Int.nat", "$plus", "$eq", "nat$drop"], "verifythis_2021_lexicographic_permutations_2.sorted_sub": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$lt", "Int.nat"], "verifythis_2021_lexicographic_permutations_2.sorted": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$lt", "Int.nat", "length$nat"], "verifythis_2021_lexicographic_permutations_2.le": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.Ex", "HOL.implies", "$eq", "$lt", "Int.nat", "length$nat"], "verifythis_2021_lexicographic_permutations_2.lt": ["HOL.eq", "$eq", "HOL.Not", "le", "HOL.conj"], "verifythis_2015_dancing_links.dll'eq": ["n", "next", "HOL.eq", "$eq", "HOL.conj", "prev"], "verifythis_2015_dancing_links.valid_in": ["$le", "n", "nat$nth", "HOL.conj", "next", "HOL.eq", "$eq", "$lt", "Int.nat", "prev"], "verifythis_2015_dancing_links.valid_out": ["$le", "n", "nat$nth", "HOL.conj", "next", "HOL.eq", "$eq", "$lt", "Int.nat", "prev"], "verifythis_2015_dancing_links.is_list": ["$le", "n", "nat$nth", "HOL.All", "HOL.conj", "HOL.If", "next", "HOL.implies", "HOL.eq", "Int.int", "$eq", "$lt", "$minus", "HOL.Not", "Int.nat", "$plus", "prev", "length$nat"], "verifythis_2021_lexicographic_permutations_2.boxed": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$times", "int.Abs.abs", "$lt", "Int.nat", "length$nat"], "verifythis_fm2012_treedel.root": ["Memory.null", "$eq"], "verifythis_fm2012_treedel.istree": ["Memory.right1", "Memory.null", "HOL.eq", "HOL.True", "$eq", "HOL.Not", "HOL.conj", "root", "Memory.left1"], "verifythis_fm2012_treedel.zip": ["$eq", "bintree.Tree.Node"], "verifythis_fm2012_treedel.inorderz": ["$append", "$eq", "list.List.Cons", "list.List.Nil", "bintree.Inorder.inorder"], "proper_cuts.injective": ["HOL.All", "HOL.implies", "HOL.eq", "$eq", "HOL.Not"], "proper_cuts.map": ["list.List.Nil", "$eq", "list.List.Cons"], "proper_cuts.cut": ["HOL.eq", "$append", "$eq"], "proper_cuts.proper_cuts": ["List.set", "HOL.All", "list.Distinct.distinct", "HOL.eq", "cut", "Set.member", "HOL.conj"], "verifythis_2021_lexicographic_permutations_2.find_le": ["nat$nth", "HOL.If", "Int.int", "$eq", "HOL.Let", "why3.Bool.Bool.True", "why3.Bool.Bool.False", "$lt", "Int.nat", "find_eq", "length$nat"], "schorr_waite.not_in_stack": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$eq", "$lt", "HOL.Not", "Int.nat", "length$nat"], "verifythis_2017_tree_buffer.cat'eq": ["ys", "HOL.eq", "$eq", "ch", "xs", "HOL.conj", "xs_len", "b"], "maximum_subarray.sum": ["fc", "int.Sum.sum", "$eq"], "schorr_waite.last": ["nat$nth", "Int.int", "$eq", "$minus", "Int.nat", "length$nat"], "schorr_waite.distinct": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$eq", "$lt", "HOL.Not", "Int.nat", "length$nat"], "schorr_waite.edge": ["HOL.eq", "HOL.disj", "$eq", "null", "HOL.Not", "HOL.conj"], "schorr_waite.path": ["edge"], "verifythis_2017_tree_buffer.rt'eq": ["ys", "HOL.eq", "$eq", "ch", "xs", "HOL.conj", "xs_len", "b"], "schorr_waite.reachable": ["HOL.eq", "HOL.Ex", "path"], "verifythis_2017_tree_buffer.take": ["HOL.If", "$eq", "$minus", "list.List.Cons", "list.List.Nil"], "verifythis_2017_tree_buffer.add": ["$eq", "xs", "list.List.Cons", "buf'mk", "h"], "verifythis_2017_tree_buffer.get": ["xs", "take", "$eq", "h"], "three_idem_ring.null": ["HOL.eq", "$eq", "mul", "zero"], "balance.spec": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.implies", "$eq", "$lt", "HOL.Not", "Int.nat", "length$nat"], "esterel.s'eq": ["bv", "HOL.eq", "$eq", "HOL.conj", "mdl"], "balance.sum": ["nat$nth", "HOL.If", "$eq", "why3.Bool.Bool.True", "$plus"], "edit_distance.min_suffix": ["HOL.eq", "MyWord.min_dist", "suffix"], "vstte10_inverting.injective": ["nat$nth", "HOL.eq", "$comp", "map.MapInjection.injective", "Int.nat"], "vstte10_inverting.surjective": ["nat$nth", "map.MapInjection.surjective", "HOL.eq", "$comp", "Int.nat"], "vstte10_inverting.range": ["nat$nth", "HOL.eq", "map.MapInjection.range", "$comp", "Int.nat"], "cubic_root.cube": ["$times", "$eq"], "edit_distance.dist": [], "edit_distance.min_dist": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "HOL.conj", "dist"], "edit_distance.last_char": ["$eq"], "edit_distance.but_last": ["list.List.Nil", "$eq", "list.List.Cons"], "vstte12_two_way_sort.le": ["HOL.eq", "HOL.disj", "$eq", "why3.Bool.Bool.True", "why3.Bool.Bool.False"], "queens.eq_prefix": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "$lt", "HOL.conj"], "vstte12_two_way_sort.sorted": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$lt", "le", "Int.nat", "length$nat"], "queens.partial_solution": ["$le", "n", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "$lt", "HOL.Not", "$minus", "HOL.conj"], "queens.lt_sol": ["$le", "n", "HOL.eq", "HOL.Ex", "$lt", "eq_prefix", "HOL.conj"], "queens.sorted": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$lt", "HOL.conj", "lt_sol"], "vacid_0_red_black_trees.memt": ["HOL.False", "HOL.eq", "HOL.disj", "$eq", "HOL.conj"], "vacid_0_red_black_trees.lt_tree": ["HOL.All", "HOL.implies", "HOL.eq", "$lt", "memt"], "vacid_0_red_black_trees.gt_tree": ["HOL.All", "HOL.implies", "HOL.eq", "$lt", "memt"], "vacid_0_red_black_trees.bst": ["HOL.eq", "HOL.True", "gt_tree", "HOL.conj", "lt_tree"], "dyck.fall": ["HOL.False", "HOL.eq", "HOL.True", "Dyck.dyck", "HOL.conj"], "dyck.dyck": [], "vacid_0_red_black_trees.inv": ["RedBlackTree.bst", "HOL.eq", "HOL.Ex", "HOL.conj", "RedBlackTree.rbtree"], "vacid_0_red_black_trees.default": ["$eq"], "vacid_0_red_black_trees.mem": ["HOL.All", "HOL.eq", "HOL.disj", "$eq", "RedBlackTree.memt", "HOL.Not", "HOL.conj"], "verifythis_2021_dll_to_bst.valid": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$eq", "set.Fset.mem", "null", "$lt", "HOL.Not", "fmap.Fmap.domain", "Int.nat", "length$nat"], "verifythis_2021_dll_to_bst.dll": ["valid", "$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.If", "fmap.Fmap.contents", "HOL.eq", "Int.int", "HOL.implies", "$eq", "null", "$lt", "$minus", "Int.nat", "$plus", "length$nat"], "verifythis_2021_dll_to_bst.tree": ["valid", "$le", "nat$nth", "HOL.conj", "fmap.Fmap.contents", "HOL.eq", "Int.int", "$eq", "null", "$lt", "Int.nat", "$plus", "length$nat"], "verifythis_2021_dll_to_bst.inorder": ["$append", "nat$nth", "$eq", "seq.Seq.empty", "seq.Seq.cons", "Int.nat"], "vacid_0_red_black_trees.is_not_red": ["HOL.eq", "HOL.True", "HOL.False"], "vacid_0_red_black_trees.rbtree": ["HOL.eq", "$eq", "is_not_red", "$minus", "HOL.conj"], "vacid_0_red_black_trees.almost_rbtree": ["HOL.eq", "$eq", "$minus", "rbtree", "HOL.conj"], "flag.monochrome": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$eq", "$lt", "Int.nat"], "verifythis_2018_array_based_queuing_lock_1.bounded_int2'eq": ["HOL.eq", "$eq", "model", "HOL.conj", "value"], "verifythis_2018_array_based_queuing_lock_1.ticket'eq": ["tvalue", "HOL.eq", "$eq"], "vstte12_bfs.path": ["succ", "set.Fset.mem"], "verifythis_2018_array_based_queuing_lock_1.ticket1": ["tvalue", "$eq"], "verifythis_2018_array_based_queuing_lock_1.released": ["HOL.eq", "HOL.True", "HOL.False"], "vstte12_bfs.inv": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "HOL.Ex", "HOL.disj", "set.Fset.mem", "Graph.shortest_path", "HOL.Not", "Graph.path", "HOL.conj", "set.Fset.subset", "$plus"], "vstte12_bfs.closure": ["Graph.succ", "HOL.All", "HOL.implies", "HOL.eq", "set.Fset.mem", "HOL.Not"], "euler_sieve.t'eq": ["max_arr", "HOL.eq", "nexts", "$eq", "arr", "max", "HOL.conj", "marked"], "euler_sieve.inv_nexts": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$lt", "Int.nat"], "euler_sieve.all_eliminated_marked": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$eq", "why3.Bool.Bool.True", "$lt", "Int.nat", "length$nat"], "euler_sieve.all_eliminated_marked_partial": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$eq", "why3.Bool.Bool.True", "$lt", "Int.nat", "length$nat"], "euler_sieve.not_marked_impl_next_not_marked": ["$le", "nat$nth", "length$nat", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.implies", "$eq", "why3.Bool.Bool.True", "HOL.Not", "$minus", "Int.nat", "int.EuclideanDivision.div"], "euler_sieve.is_copy": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$eq", "why3.Bool.Bool.True", "$lt", "HOL.Not", "Int.nat", "length$nat"], "euler_sieve.not_marked_impl_next_not_marked_partial": ["$le", "nat$nth", "length$nat", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.implies", "$eq", "why3.Bool.Bool.True", "$lt", "$minus", "HOL.Not", "Int.nat", "int.EuclideanDivision.div"], "euler_sieve.all_primes": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$eq", "why3.Bool.Bool.True", "$lt", "HOL.Not", "Int.nat", "number.Prime.prime"], "euler_sieve.all_multiples_marked": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.implies", "$times", "$eq", "why3.Bool.Bool.True", "$lt", "Int.nat", "length$nat"], "euler_sieve.previously_marked_multiples": ["$le", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$lt", "all_multiples_marked", "length$nat"], "euler_sieve.only_multiples_marked": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "HOL.Ex", "$eq", "why3.Bool.Bool.True", "$times", "$lt", "Int.nat", "length$nat"], "euler_sieve.prime_multiples_marked": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.implies", "$times", "$eq", "why3.Bool.Bool.True", "$lt", "HOL.Not", "Int.nat", "length$nat"], "euler_sieve.inv_remove_products": ["nat$nth", "inv_nexts", "HOL.conj", "all_primes", "HOL.eq", "Int.int", "$eq", "why3.Bool.Bool.True", "HOL.Not", "Int.nat", "number.Prime.prime", "length$nat"], "fibonacci.mult": ["a21", "a12", "$times", "t'mk", "$eq", "a22", "a11", "$plus"], "verifythis_2021_shearsort.mocc": ["int.Sum.sum", "moccf", "$eq"], "verifythis_2021_shearsort.below_column": ["HOL.eq", "$le"], "verifythis_2021_shearsort.above_column": ["HOL.eq", "$lt"], "fibonacci.sum": ["int.Fibonacci.fib", "$plus", "$eq"], "fibonacci.wf": ["$le", "HOL.True", "HOL.eq", "HOL.conj", "$plus"], "verifythis_2021_shearsort.qs_partition": ["$le", "nat$nth", "HOL.All", "HOL.eq", "HOL.implies", "$eq", "ArrayPermut$permut_sub", "$lt", "Int.nat", "HOL.conj"], "vstte10_max_sum.is_max": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "HOL.disj", "HOL.Ex", "$eq", "$lt", "Int.nat"], "residual.mem": ["Star"], "toy_compiler.compile": ["$append", "StackMachine.Push", "$eq", "StackMachine.Add", "list.List.Cons", "list.List.Nil", "StackMachine.Sub", "StackMachine.Mul"], "euler_sieve.inv_count": ["nat$nth", "int.Abs.abs", "int.EuclideanDivision.div", "length$nat", "$le", "HOL.All", "$times", "Int.nat", "mach.int.Int63.int63'int", "HOL.implies", "Int.int", "mach.int.Int63.max_int", "$uminus", "HOL.eq", "$lt", "HOL.Not", "HOL.conj", "$plus", "number.Prime.prime"], "fibonacci.snoc": ["list.List.Nil", "$eq", "list.List.Cons"], "mergesort_queue.sorted_sub": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$lt", "le", "Int.nat"], "mergesort_queue.sorted": ["HOL.eq", "Int.int", "sorted_sub", "length$nat"], "pairing_heap.occ_heap": ["$eq"], "vstte12_tree_reconstruction.forest_depths": ["Tree.depths", "list.List.Nil", "$eq", "$append"], "vstte12_tree_reconstruction.greedy": ["HOL.True", "HOL.eq", "$eq", "HOL.Not", "HOL.conj", "$plus"], "pairing_heap.occ_tree": ["$plus", "$eq", "HOL.If"], "pairing_heap.occ_list": ["$plus", "$eq"], "vstte12_tree_reconstruction.g": ["greedy", "list.List.Cons"], "vstte12_tree_reconstruction.only_leaf": ["Tree.Leaf", "HOL.True", "HOL.eq", "$eq", "HOL.conj"], "flexible_arrays.t'eq": ["tree", "HOL.eq", "$eq", "HOL.conj", "size"], "pairing_heap.le_tree": ["HOL.eq", "le"], "pairing_heap.le_root": ["le_tree", "HOL.eq", "HOL.True"], "pairing_heap.le_roots": ["le_tree", "HOL.eq", "HOL.True", "HOL.conj"], "pairing_heap.heap": ["HOL.eq", "HOL.True"], "pairing_heap.heap_tree": ["HOL.eq", "HOL.conj", "le_roots"], "pairing_heap.heap_list": ["HOL.eq", "HOL.True", "HOL.conj"], "pairing_heap.heap'eq": ["HOL.eq", "$eq", "h"], "pairing_heap.size": ["$eq", "h", "Size.size_heap"], "pairing_heap.occ": ["Occ.occ_heap", "h", "$eq"], "pairing_heap.is_minimum_tree": ["HOL.All", "HOL.implies", "Occ.mem_tree", "HOL.eq", "le", "HOL.conj"], "pairing_heap.is_minimum": ["Occ.mem", "HOL.All", "PairingHeap.le", "mem", "HOL.implies", "HOL.eq", "le", "HOL.conj"], "pairing_heap.minimum_heap": ["minimum", "$eq", "h"], "vstte12_tree_reconstruction.depths": ["$append", "$eq", "list.List.Cons", "list.List.Nil", "$plus"], "flexible_arrays.braun": ["HOL.eq", "HOL.True", "HOL.disj", "$eq", "HOL.conj", "bintree.Size.size", "$plus"], "verifythis_2021_shearsort_modified.mocc": ["fc", "int.Sum.sum", "$eq", "matrix.Matrix.rows"], "dreal.sqr": ["$times", "$eq"], "verifythis_2021_shearsort_modified.lt": ["int.ComputerDivision.mod", "HOL.If", "HOL.eq", "HOL.disj", "$eq", "$lt", "HOL.conj"], "verifythis_2021_shearsort_modified.snake_order": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "HOL.Let", "matrix.Matrix.rows", "matrix.Matrix.columns", "$lt", "HOL.conj", "lt", "matrix.Matrix.elts"], "verifythis_2021_shearsort_modified.inversions": ["fc4", "int.Sum.sum", "$eq", "matrix.Matrix.rows"], "verifythis_2021_shearsort_modified.sorted_row": ["$le", "HOL.All", "HOL.If", "HOL.implies", "HOL.eq", "$eq", "why3.Bool.Bool.True", "matrix.Matrix.rows", "$lt", "matrix.Matrix.columns", "HOL.conj", "matrix.Matrix.elts"], "verifythis_2021_shearsort_modified.sorted_column": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "matrix.Matrix.rows", "$lt", "matrix.Matrix.columns", "HOL.conj", "matrix.Matrix.elts"], "vstte12_tree_reconstruction.map_leaf": ["Tree.Leaf", "list.List.Nil", "$eq", "list.List.Cons"], "ropes.infix_eqeq": ["$le", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$eq", "$lt", "length", "mixfix_lbrb"], "pairing_heap.size_heap": ["$eq"], "pairing_heap.size_tree": ["$plus", "$eq"], "pairing_heap.size_list": ["$plus", "$eq"], "pairing_heap_bin.size": ["bintree.Size.size", "$plus", "$eq"], "ropes.string_of_queue": ["Int.int", "string_of_array", "$eq", "length$nat"], "register_allocation.n": ["HOL.If", "$eq", "HOL.Let", "int.MinMax.max", "$plus"], "register_allocation.measure": ["$le", "n", "HOL.If", "$eq", "$plus"], "ropes.length": ["$eq"], "ropes.inv": ["$le", "HOL.conj", "HOL.True", "HOL.eq", "$eq", "$lt", "length", "MyString.length", "$plus"], "ropes.string": ["MyString.empty", "MyString.sub", "MyString.app", "$eq"], "pairing_heap_bin.le_root": ["HOL.eq", "HOL.True", "le"], "pairing_heap_bin.le_root_tree": ["HOL.eq", "HOL.True", "HOL.conj", "le"], "pairing_heap_bin.heap_tree": ["HOL.eq", "HOL.True", "HOL.conj", "le_root_tree"], "pairing_heap_bin.heap": ["HOL.eq", "HOL.True", "heap_tree", "le_root_tree", "HOL.conj"], "pairing_heap_bin.is_minimum": ["HOL.All", "mem", "HOL.implies", "HOL.eq", "le", "HOL.conj", "MyOcc.mem"], "pairing_heap.mem": ["HOL.eq", "$lt", "PairingHeap.occ", "occ"], "register_allocation.hcode_ok": ["HOL.All", "HOL.eq", "post1", "$eq", "why3.Bool.Bool.True", "hcode1", "Spec.exec_list"], "register_allocation.wcode_ok": ["trans1", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "why3.Bool.Bool.True", "wcode1", "Spec.exec_list"], "pancake_sorting.sorted": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "$lt", "Int.nat"], "fib_memo.inv": ["HOL.All", "HOL.implies", "HOL.eq", "$eq", "int.Fibonacci.fib", "option.Option.Some"], "register_allocation.eval": ["$uminus", "$plus", "$eq"], "register_allocation.exec": ["mem", "state'mk", "reg", "$eq", "st", "$uminus", "list.List.Cons", "update", "$plus"], "register_allocation.exec_list": ["exec", "$eq"], "kmp.matches1": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.implies", "$eq", "$lt", "$minus", "Int.nat", "$plus", "length$nat"], "kmp.is_next": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$lt", "$minus", "HOL.Not", "matches1", "HOL.conj"], "kmp.first_occur": ["$le", "HOL.All", "HOL.implies", "Int.int", "HOL.eq", "$lt", "HOL.Not", "matches1", "HOL.conj", "length$nat"], "vstte12_ring_buffer.buffer'eq": ["len", "HOL.eq", "data", "first", "$eq", "sequence", "HOL.conj"], "vstte12_ring_buffer.size": ["data", "length$nat", "Int.int", "$eq"], "pairing_heap_bin.mem": ["HOL.eq", "$lt", "occ"], "verifythis_2017_maximum_sum_submatrix.array_sum": ["mixfix_lbrb_closure", "$eq", "int.Sum.sum"], "verifythis_2017_maximum_sum_submatrix.col": ["matrix.Matrix.elts", "$eq"], "verifythis_2017_maximum_sum_submatrix.matrix_sum": ["fc", "int.Sum.sum", "$eq"], "pairing_heap_bin.occ": ["bintree.Occ.occ", "$plus", "$eq", "HOL.If"], "foveoos11_challenge3.appear_twice": ["$le", "nat$nth", "HOL.conj", "HOL.eq", "HOL.Ex", "$eq", "$lt", "HOL.Not", "Int.nat"], "bitwalker.nth8_stream": ["int.EuclideanDivision.mod", "nat$nth", "$eq", "$neq", "take_bit$nat", "$minus", "Int.nat", "int.EuclideanDivision.div"], "bitwalker.maxvalue": ["lsl$nat", "$unat", "$eq", "bv.BVConverter_32_64.toBig"], "disamb.pe": [], "disamb.pe'": [], "disamb.pt": [], "tree_height.is_id": ["HOL.eq", "HOL.True", "HOL.False"], "tree_height.is_result": ["HOL.eq", "HOL.True", "HOL.False"], "tree_height.evalk": ["bintree.Height.height", "int.MinMax.max", "$plus", "$eq"], "tree_height.evalw": ["bintree.Height.height", "$eq"], "tree_height.sizek": ["$times", "bintree.Size.size", "$plus", "$eq"], "tree_height.sizew": ["$times", "bintree.Size.size", "$plus", "$eq"], "anagrammi.perm4": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.implies", "list.Distinct.distinct", "$eq", "$lt", "Int.nat", "length$nat"], "anagrammi.lt": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "HOL.Ex", "$eq", "$lt", "Int.nat"], "anagrammi.sorted": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$lt", "Int.nat", "perm4", "lt", "length$nat"], "anagrammi.below": ["$le", "nat$nth", "List.set", "HOL.All", "HOL.conj", "HOL.eq", "HOL.implies", "Int.int", "$eq", "why3.Bool.Bool.True", "sorted", "$lt", "Int.nat", "Set.member", "perm4", "length$nat"], "topological_sorting.inv": ["$le", "HOL.All", "HOL.conj", "Graph.vertices", "values", "HOL.eq", "HOL.implies", "Graph.sort", "set.Fset.mem", "$lt", "defined_sort", "partial_sort", "contents", "graph", "mixfix_lbrb", "set.Fset.subset"], "warshall_algorithm.path": ["$le", "$eq", "why3.Bool.Bool.True", "$lt", "matrix.Matrix.elts"], "tree_height.heights": ["bintree.Height.height", "int.MinMax.max", "$plus", "$eq"], "tree_height.sizes": ["bintree.Size.size", "$plus", "$eq"], "leftist_heap.le_root": ["HOL.eq", "HOL.True", "le"], "leftist_heap.is_heap": ["HOL.eq", "HOL.True", "le_root", "HOL.conj"], "topological_sorting.partial_sort": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "mixfix_lbrb", "set.Fset.mem", "Graph.edges", "$lt", "HOL.conj"], "leftist_heap.is_minimum": ["Occ.mem", "HOL.All", "HOL.implies", "HOL.eq", "le", "HOL.conj"], "leftist_heap.rank": ["int.MinMax.min", "$plus", "$eq"], "leftist_heap.leftist": ["$le", "rank", "HOL.True", "HOL.eq", "$eq", "HOL.conj"], "leftist_heap.leftist_heap": ["is_heap", "HOL.eq", "HOL.conj", "leftist"], "verifythis_fm2012_LRS.permutation": ["HOL.eq", "map.MapInjection.range", "map.MapInjection.injective", "HOL.conj"], "verifythis_fm2012_LRS.suffixArray'eq": ["values", "HOL.eq", "$eq", "HOL.conj", "suffixes"], "bitcount.nth_diff": ["HOL.eq", "$eq", "$neq", "take_bit$nat", "HOL.Not", "Int.nat"], "bitcount.hammingD_logic": ["nth_diff_closure", "int.NumOf.numof", "$eq"], "verifythis_fm2012_LRS.lt": ["$le", "LCP.is_common_prefix", "nat$nth", "HOL.conj", "HOL.eq", "Int.int", "HOL.Ex", "HOL.disj", "$eq", "HOL.Let", "$lt", "Int.nat", "$plus", "length$nat"], "bitcount.validAscii": ["number.Parity.even", "HOL.eq", "BitCounting32.count_logic"], "bitcount.nth_as_bv": ["$unat", "HOL.If", "$eq", "$neq", "take_bit$nat", "why3.Bool.Bool.True"], "bitcount.nth_as_int": ["HOL.If", "$eq", "why3.Bool.Bool.True", "take_bit$nat", "$neq", "Int.nat"], "verifythis_2018_mind_the_gap_2.buffer'eq": ["HOL.eq", "data", "l", "$eq", "r", "HOL.conj"], "verifythis_2018_mind_the_gap_2.len_contents": ["data", "Int.int", "l", "$eq", "r", "$minus", "$plus", "length$nat"], "verifythis_2018_mind_the_gap_2.same_contents": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "$lt", "len_contents", "contents", "HOL.conj"], "verifythis_fm2012_LRS.is_common_prefix": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.implies", "$eq", "$lt", "Int.nat", "$plus", "length$nat"], "verifythis_fm2012_LRS.is_longest_common_prefix": ["HOL.All", "is_common_prefix", "HOL.eq", "HOL.implies", "$lt", "HOL.Not", "HOL.conj"], "bitcount.step0": ["$unat", "HOL.eq", "lsr$nat", "$eq", "bit$and", "$minus"], "bitcount.step1": ["$unat", "HOL.eq", "lsr$nat", "$eq", "bit$and", "$plus"], "bitcount.step2": ["$unat", "HOL.eq", "lsr$nat", "$eq", "bit$and", "$plus"], "bitcount.step3": ["$unat", "HOL.eq", "lsr$nat", "$eq", "$plus"], "bitcount.step4": ["$unat", "HOL.eq", "lsr$nat", "$eq", "$plus"], "bitcount.count_logic": ["nth_closure", "int.NumOf.numof", "$eq"], "verifythis_2018_mind_the_gap_2.contents_inserted": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "$lt", "$minus", "len_contents", "contents", "HOL.conj", "$plus"], "verifythis_2018_mind_the_gap_2.contents_deleted": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "$lt", "$minus", "len_contents", "contents", "HOL.conj", "$plus"], "leftist_heap.size": ["$plus", "$eq"], "leftist_heap.occ": ["$plus", "$eq", "HOL.If"], "verifythis_fm2012_LRS.range": ["nat$nth", "HOL.eq", "map.MapInjection.range", "Int.int", "$comp", "Int.nat", "length$nat"], "verifythis_fm2012_LRS.le": ["HOL.eq", "lt", "HOL.disj", "$eq"], "tree_height.leaves": ["bintree.Size.size", "$plus", "$eq"], "muller.numof": ["fc", "int.NumOf.numof", "$eq"], "verifythis_fm2012_LRS.sorted_sub": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$lt", "le", "HOL.conj"], "verifythis_fm2012_LRS.sorted": ["nat$nth", "HOL.eq", "Int.int", "$comp", "sorted_sub", "Int.nat", "length$nat"], "verifythis_2015_relaxed_prefix.eq_array": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.eq", "Int.int", "HOL.implies", "$eq", "$lt", "Int.nat", "$plus", "length$nat"], "verifythis_2015_relaxed_prefix.is_relaxed_prefix": ["$le", "eq_array", "HOL.eq", "Int.int", "HOL.disj", "HOL.Ex", "HOL.Let", "$lt", "$minus", "HOL.conj", "$plus", "length$nat"], "lemma_functions.length": ["$plus", "$eq"], "test_elim.f": ["HOL.eq", "$lt", "$plus"], "ccursor.cursor'eq": ["current", "new", "bound", "freed", "len", "HOL.eq", "$eq", "HOL.conj"], "rac.mixfix_lbrb'": ["$eq", "elts"], "rac.mixfix_lbrb": ["$eq", "elts"], "tables.key": ["$eq"], "tables.selection_possible": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$lt", "key", "Int.nat", "lt", "length$nat"], "tables.upper_bound_s": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$lt", "key", "Int.nat", "lt", "length$nat"], "tables.lower_bound_s": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$lt", "key", "Int.nat", "lt", "length$nat"], "tables.selected": ["avl.SelectionTypes.left1", "HOL.eq", "HOL.True", "$eq", "lower_bound_s", "avl.SelectionTypes.middle", "upper_bound_s", "key", "HOL.conj", "eq", "avl.SelectionTypes.right1"], "tables.node_model": ["$append", "$eq", "seq.Seq.cons"], "tables.seq_model": ["node_model", "$eq", "seq.Seq.empty"], "tables.real_height": ["HOL.If", "$eq", "HOL.Let", "$lt", "$plus"], "tables.balanced": ["$le", "HOL.True", "Int.int", "HOL.eq", "$eq", "$minus", "$uminus", "HOL.conj", "balancing", "real_height"], "tables.t'eq": ["HOL.eq", "repr", "$eq", "HOL.conj", "m1"], "tables.t'eq1": ["HOL.eq", "field", "$eq"], "tables.domain": ["$le", "nat$nth", "HOL.conj", "HOL.eq", "Int.int", "HOL.Ex", "$eq", "$lt", "key", "Int.nat", "eq", "length$nat"], "tables.m3": ["make_func_closure", "seq", "domain_closure", "$eq", "m'mk1", "Int.int", "field", "m1", "length$nat"], "tables.m5": ["m'mk2", "card", "m3", "$eq", "domn", "fc"], "ral.measure": ["$eq"], "ral.selection_possible": ["$le", "HOL.If", "HOL.eq", "Int.int", "$eq", "why3.Bool.Bool.True", "$lt", "HOL.conj", "hole", "index", "length$nat"], "ral.selected": ["avl.SelectionTypes.left1", "option.Option.None", "HOL.eq", "Int.int", "$eq", "why3.Bool.Bool.True", "avl.SelectionTypes.middle", "HOL.conj", "hole", "index", "length$nat"], "ral.node_model": ["$append", "$eq", "seq.Seq.cons"], "ral.seq_model": ["node_model", "$eq", "seq.Seq.empty"], "ral.real_height": ["HOL.If", "$eq", "HOL.Let", "$lt", "$plus"], "ral.balanced": ["$le", "measure_closure", "HOL.True", "Int.int", "HOL.eq", "$eq", "balancing", "$minus", "seq_model", "HOL.conj", "$uminus", "real_height", "agg"], "ral.t'eq": ["m2", "HOL.eq", "$eq", "HOL.conj", "repr"], "avl.option_to_seq": ["seq.Seq.singleton", "$eq", "seq.Seq.empty"], "avl.rebuild": ["$append", "right1", "$eq", "left1", "middle", "option_to_seq"], "avl.left_extend": ["$append", "split'mk", "right1", "$eq", "seq.Seq.cons", "left1", "middle"], "priority_queue.op": ["lt", "$eq", "HOL.If"], "priority_queue.measure": ["key", "option.Option.Some", "$eq"], "priority_queue.selection_possible": ["HOL.eq", "Int.int", "$eq", "HOL.Not", "length$nat"], "priority_queue.lower_bound": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$lt", "le", "key", "Int.nat", "length$nat"], "priority_queue.lower_bound_strict": ["$le", "nat$nth", "HOL.All", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "$lt", "key", "Int.nat", "lt", "length$nat"], "priority_queue.selected": ["avl.SelectionTypes.left1", "HOL.False", "HOL.eq", "lower_bound", "avl.SelectionTypes.middle", "lower_bound_strict", "key", "HOL.conj", "avl.SelectionTypes.right1"], "priority_queue.node_model": ["$append", "$eq", "seq.Seq.cons"], "priority_queue.seq_model": ["node_model", "$eq", "seq.Seq.empty"], "priority_queue.real_height": ["HOL.If", "$eq", "HOL.Let", "$lt", "$plus"], "priority_queue.balanced": ["$le", "measure_closure", "HOL.True", "Int.int", "HOL.eq", "$eq", "balancing", "$minus", "seq_model", "HOL.conj", "$uminus", "real_height", "agg"], "priority_queue.t'eq": ["HOL.eq", "repr", "$eq", "HOL.conj", "m1"], "avl.node_model": ["$append", "$eq", "seq.Seq.cons"], "avl.seq_model": ["node_model", "$eq", "seq.Seq.empty"], "avl.real_height": ["HOL.If", "$eq", "HOL.Let", "$lt", "$plus"], "avl.balanced": ["$le", "measure_closure", "HOL.True", "Int.int", "HOL.eq", "$eq", "balancing", "$minus", "seq_model", "HOL.conj", "$uminus", "real_height", "agg"], "avl.t'eq": ["HOL.eq", "repr", "$eq", "HOL.conj", "m1"], "duplets.is_duplet": ["$le", "nat$nth", "HOL.conj", "HOL.eq", "Int.int", "$eq", "$lt", "Int.nat", "length$nat"], "duplets.eq_opt": ["HOL.eq", "HOL.False", "$eq"], "tree_max.mem": ["HOL.eq", "HOL.disj", "HOL.False", "$eq"], "tree_max.ge_tree": ["HOL.eq", "HOL.True", "HOL.conj", "$le"], "priority_queue.m3": ["to_bag", "nat$nth", "get_minimum_index", "Int.int", "seq", "$eq", "m'mk1", "Int.nat", "m1", "length$nat"], "sqrtrem.ceilhalf": ["$plus", "$eq", "int.ComputerDivision.div"], "base_info.wmpn_base_info'eq": ["HOL.eq", "exp", "$eq", "bb", "HOL.conj", "b"], "rac.char'eq": ["HOL.eq", "char'int", "$eq"], "rac.p": ["HOL.eq", "$lt", "HOL.conj", "$le"], "stringlemmas.num_to_lowercase_text": ["$le", "nat$nth", "HOL.conj", "HOL.If", "$eq", "$lt", "string.Char.chr", "mach.c.UChar.uchar'int", "Int.nat", "$uminus"], "stringlemmas.to_lowercase_text": ["$le", "HOL.All", "num_to_lowercase_text", "HOL.implies", "HOL.eq", "$eq", "$lt", "HOL.conj"], "stringlemmas.num_to_uppercase_text": ["$le", "nat$nth", "HOL.conj", "HOL.If", "$eq", "$lt", "string.Char.chr", "mach.c.UChar.uchar'int", "Int.nat", "$uminus"], "stringlemmas.to_uppercase_text": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "num_to_uppercase_text", "$lt", "HOL.conj"], "stringlemmas.num_to_bothcase_text": ["$le", "nat$nth", "HOL.conj", "HOL.If", "$eq", "$lt", "string.Char.chr", "mach.c.UChar.uchar'int", "Int.nat", "$uminus"], "stringlemmas.to_bothcase_text": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "$lt", "HOL.conj", "num_to_bothcase_text"], "stringlemmas.in_base": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$lt", "mach.c.UChar.uchar'int", "HOL.conj"], "stringlemmas.string_in_base": ["in_base", "nat$nth", "mach.c.String.strlen", "HOL.eq", "mach.c.C.max", "HOL.disj", "$eq", "text_in_base", "$lt", "mach.c.C.pelts", "HOL.conj", "$plus", "mach.c.C.min"], "stringlemmas.svalue_le": ["$eq", "svalue_le_sub", "mach.c.C.pelts", "mach.c.C.offset", "$plus"], "stringlemmas.svalue": ["$eq", "mach.c.C.pelts", "mach.c.C.offset", "$plus", "svalue_sub"], "lemmas.map_eq_sub_shift": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "$lt", "HOL.conj", "$plus"], "stringlemmas.text_to_num_onecase": ["$le", "nat$nth", "$plus", "HOL.If", "$eq", "string.Char.code", "$minus", "HOL.conj", "$uminus"], "stringlemmas.text_to_num_bothcase": ["$le", "nat$nth", "$plus", "HOL.If", "$eq", "string.Char.code", "$minus", "HOL.conj", "$uminus"], "stringlemmas.text_to_num": ["$le", "HOL.If", "$eq", "text_to_num_onecase", "text_to_num_bothcase", "HOL.conj", "$uminus"], "stringlemmas.num_to_text": ["$le", "num_to_bothcase_text", "HOL.If", "num_to_lowercase_text", "$eq", "num_to_uppercase_text", "$lt", "string.Char.chr", "HOL.conj", "$uminus"], "stringlemmas.to_num": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "text_to_num", "$lt", "mach.c.UChar.uchar'int", "HOL.conj"], "lemmas.value": ["value_sub", "$eq", "mach.c.C.pelts", "mach.c.C.offset", "$plus"], "mpz_get_str.effective": ["$lt", "int.Abs.abs", "$eq", "HOL.If"], "powm.redc": ["int.EuclideanDivision.mod", "$times", "HOL.eq", "int.Power.power", "$eq", "$plus"], "powm.valueb": ["mach.int.UInt64Gen.uint64'int", "int.EuclideanDivision.mod", "lemmas.Lemmas.value", "HOL.If", "$times", "int.Power.power", "$eq", "HOL.Let", "$lt", "$minus", "mach.c.C.pelts", "mach.c.C.offset", "$plus", "int.EuclideanDivision.div"], "mpz.value_of": ["$times", "sgn", "abs_value_of", "$eq"], "mpz.sgn_value": ["$le", "mach.int.Int32.int32'int", "HOL.If", "$eq", "lemmas.Lemmas.value", "$uminus"], "mpz.mpz_unchanged": ["HOL.implies", "HOL.eq", "$eq", "alloc", "$lt", "abs_size", "$uminus", "zones", "HOL.conj", "sgn", "abs_value_of", "readers"], "stringlemmas.abs_value_text": ["abs_value_sub_text", "$plus", "$eq", "mach.c.String.strlen"], "stringlemmas.value_text": ["nat$nth", "HOL.If", "abs_value_text", "$eq", "$uminus", "$plus"], "stringlemmas.text_in_base": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$lt", "HOL.conj", "Conversions.text_to_num"], "mpz_realloc2.alloc_of_bits": ["$le", "HOL.If", "$eq", "$plus", "int.EuclideanDivision.div"], "div.reciprocal": ["mach.int.UInt64Gen.uint64'int", "$times", "HOL.eq", "$eq", "$minus", "$plus", "int.EuclideanDivision.div"], "div.reciprocal_3by2": ["mach.int.UInt64Gen.uint64'int", "$times", "HOL.eq", "$eq", "$minus", "$plus", "int.EuclideanDivision.div"], "div.normalized": ["$le", "mach.int.UInt64Gen.uint64'int", "mach.int.Int32.int32'int", "mach.c.C.valid", "HOL.eq", "$minus", "mach.c.C.pelts", "mach.c.C.offset", "HOL.conj", "$plus", "int.EuclideanDivision.div"], "lineardecision.mpinterp": ["MP64Coeffs.interp_exp", "int.Power.power", "$plus", "$eq"], "lineardecision.valid_expr": ["HOL.eq", "HOL.True", "HOL.conj", "$le"], "lineardecision.expr_bound": ["HOL.eq", "HOL.True", "HOL.conj", "$le"], "lineardecision.interp": ["$times", "$eq", "$plus", "mpinterp", "interp_id"], "lineardecision.valid_eq": ["valid_expr", "HOL.conj", "HOL.eq"], "lineardecision.eq_bound": ["HOL.eq", "HOL.conj", "expr_bound"], "lineardecision.valid_ctx": ["HOL.eq", "HOL.True", "valid_eq", "HOL.conj"], "lineardecision.ctx_bound": ["HOL.eq", "HOL.True", "HOL.conj", "eq_bound"], "lineardecision.interp_eq": ["interp", "HOL.If", "interp1", "$eq", "why3.Bool.Bool.True", "why3.Bool.Bool.False"], "lineardecision.interp_ctx": ["HOL.If", "HOL.implies", "interp_eq", "$eq", "why3.Bool.Bool.True", "why3.Bool.Bool.False"], "lineardecision.atom": ["HOL.eq", "HOL.True", "HOL.False"], "lineardecision.interp_c": ["interp", "$times", "$eq", "interp_id", "mpinterp", "infix_as"], "lineardecision.interp'": ["interp", "$times", "interp_id", "$eq", "infix_pl", "infix_mn", "interp_c", "$minus", "$plus", "mpinterp", "infix_as"], "lineardecision.interp_eq'": ["HOL.If", "interp'", "$eq", "why3.Bool.Bool.True", "why3.Bool.Bool.False"], "lineardecision.interp_ctx'": ["HOL.If", "HOL.implies", "$eq", "why3.Bool.Bool.True", "why3.Bool.Bool.False", "interp_eq'"], "lineardecision.valid_expr'": ["HOL.eq", "HOL.True", "HOL.conj", "$le"], "lineardecision.valid_eq'": ["HOL.eq", "valid_expr'", "HOL.conj"], "lineardecision.valid_ctx'": ["HOL.eq", "HOL.True", "HOL.conj", "valid_eq'"], "lineardecision.pos_exp": ["MP64Coeffs.interp_exp", "HOL.eq", "HOL.True", "$le"], "lineardecision.pos_cprod": ["HOL.eq", "pos_exp", "HOL.conj"], "lineardecision.pos_expr'": ["HOL.eq", "HOL.True", "pos_exp", "pos_cprod", "HOL.conj"], "lineardecision.pos_eq'": ["pos_expr'", "HOL.eq", "HOL.conj"], "lineardecision.pos_ctx'": ["pos_eq'", "HOL.eq", "HOL.True", "HOL.conj"], "lineardecision.m": ["MP64Coeffs.Lit", "$eq"], "lineardecision.m_cprod": ["LinearDecisionRationalMP.C", "m", "$eq", "LinearDecisionRationalMP.Times"], "lineardecision.interp1": ["infix_as", "infix_pl", "$eq", "interp"], "compare.compare_int": ["$lt", "$uminus", "$eq", "HOL.If"], "lineardecision.interp_id": ["$eq"], "matrices.block": ["ofs2", "MyMatrix.create", "$eq"], "matrices.c_blocks": ["MyMatrix.cols", "$le", "HOL.conj", "HOL.eq", "$eq", "$minus", "block", "MyMatrix.rows"], "matrices.r_blocks": ["$le", "MyMatrix.cols", "HOL.conj", "HOL.eq", "$eq", "$minus", "block", "MyMatrix.rows"], "matrices_ring_simp.l_mdl": ["matrices.MatrixArithmetic.mul", "matrices.MyMatrix.create", "$eq", "matrices.MatrixArithmetic.zerof", "$uminus"], "matrices_ring_simp.l_vld": ["HOL.False", "HOL.eq", "$eq", "matrices.MyMatrix.cols", "matrices.MyMatrix.rows", "HOL.conj"], "matrices_ring_simp.m_mdl": ["HOL.If", "m_pos", "m_prod", "$eq", "HOL.Let", "why3.Bool.Bool.True", "l_mdl", "matrices.MatrixArithmetic.opp"], "matrices_ring_simp.lm_mdl": ["matrices.MyMatrix.create", "matrices.MatrixArithmetic.add", "$eq", "m_mdl", "matrices.MatrixArithmetic.zerof"], "matrices_ring_simp.lm_mdl_simp": ["matrices.MyMatrix.create", "matrices.MatrixArithmetic.add", "$eq", "m_mdl", "matrices.MatrixArithmetic.zerof"], "matrices_ring_simp.lm_vld": ["HOL.eq", "HOL.True", "HOL.conj", "m_prod", "l_vld"], "matrices_ring_simp.l_compare": ["$lt", "$uminus", "$eq", "HOL.If"], "matrices_ring_simp.m_lower": ["m_pos", "HOL.eq", "HOL.implies", "HOL.disj", "$eq", "HOL.Let", "why3.Bool.Bool.True", "$lt", "l_compare", "HOL.conj", "m_prod"], "matrices_ring_simp.m_collapse": ["HOL.If", "m_pos", "$eq", "why3.Bool.Bool.True", "HOL.Not", "list.List.Cons", "l_compare", "HOL.conj", "list.List.Nil", "m_prod"], "matrices_ring_simp.lm_collapse": ["m_collapse", "$eq"], "matrices_ring_simp.cat_rev": ["$eq", "list.List.Cons"], "matrices_ring_simp.lm_dump": ["HOL.If", "$eq", "m_collapse", "m_lower", "list.List.Nil"], "matrices_ring_simp.lm_merge": ["lm_collapse", "$eq", "m_collapse", "cat_rev", "list.List.Nil", "lm_dump"], "matrices_ring_simp.cat": ["$eq", "list.List.Cons"], "matrices_ring_simp.m_mul": ["mono'mk", "cat", "m_pos", "HOL.eq", "HOL.If", "$eq", "why3.Bool.Bool.True", "why3.Bool.Bool.False", "m_prod"], "matrices_ring_simp.m_distribute": ["list.List.Nil", "$eq", "m_mul", "list.List.Cons"], "matrices_ring_simp.lm_distribute": ["lm_merge", "list.List.Nil", "$eq", "m_distribute"], "matrices_ring_simp.lm_opp": ["mono'mk", "HOL.If", "m_pos", "$eq", "why3.Bool.Bool.True", "lm_merge", "why3.Bool.Bool.False", "HOL.Not", "list.List.Cons", "list.List.Nil", "m_prod"], "matrices_ring_simp.empty": ["fc", "$eq"], "matrices_ring_simp.e_vld": ["$le", "HOL.eq", "e_rows", "e_cols", "ev_f", "HOL.conj", "lm_vld", "e_body"], "matrices_ring_simp.e_mdl": ["lm_mdl_simp", "e_rows", "$eq", "ev_f", "e_body", "e_cols"], "matrices_ring_simp.symb_mat": ["mono'mk", "$eq", "why3.Bool.Bool.True", "matrices.MyMatrix.cols", "list.List.Cons", "matrices.MyMatrix.rows", "list.List.Nil", "expr'mk"], "matrices_ring_simp.symb_opp": ["lm_opp", "expr'mk", "$eq", "e_rows", "e_cols", "e_body"], "stringCheck.is_digit": ["$le", "HOL.eq", "$eq", "HOL.conj", "string.StringRealization.length", "string.StringRealization.to_int"], "matrices.add": ["MyMatrix.cols", "add2f", "MyMatrix.create", "$eq", "MyMatrix.rows"], "matrices.opp": ["MyMatrix.cols", "MyMatrix.create", "$eq", "opp2f", "MyMatrix.rows"], "matrices.sub": ["$eq", "add", "opp"], "matrices.mul": ["MyMatrix.cols", "MyMatrix.create", "$eq", "mul_cell", "MyMatrix.rows"], "naive.matrix_product": ["$le", "HOL.All", "mul_atom", "HOL.implies", "HOL.eq", "int.Sum.sum", "$eq", "matrix.Matrix.rows", "$lt", "matrix.Matrix.columns", "HOL.conj", "matrix.Matrix.elts"], "imp.eval_expr": ["Eunbound_var", "option.Option.None", "$eq", "Enormal", "option.Option.Some"], "imp.identifiers_in_expr": ["set.Fset.union", "$eq", "set.Fset.add", "set.Fset.empty"], "imp.config'eq": ["HOL.eq", "loop_limit", "$eq"], "lineardecision.qinterp": ["real.FromInt.from_int", "real.Real.infix_sl", "$eq"], "lineardecision.interp_exp": ["$plus", "$minus", "$uminus", "$eq"], "lineardecision.minterp": ["$times", "qinterp", "$eq", "real.FromInt.from_int", "interp_exp", "$plus", "real.PowerReal.pow"], "matrices.set": ["cols", "create", "$eq", "fc", "rows"], "my_strassen.mdl": ["matrices.MyMatrix.create", "$eq", "matrix.Matrix.rows", "matrix.Matrix.columns", "matrix.Matrix.elts"], "my_strassen.with_symb_vld": ["matrices_ring_simp.Symb.e_vld", "matrices_ring_simp.Symb.e_mdl", "matrices_ring_simp.Symb.e_cols", "HOL.eq", "phy", "$eq", "matrices.MyMatrix.cols", "matrices_ring_simp.Symb.e_rows", "sym", "HOL.conj", "matrices.MyMatrix.rows", "mdl"], "imp.state_extends": ["SymState.rho", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "set.Fset.mem", "SymState.vars", "HOL.conj", "set.Fset.subset", "Svar.to_fset"], "lineardecision.pure_same_exp": ["HOL.False", "HOL.eq", "HOL.disj", "$eq", "HOL.conj"], "matrices_ring_simp.symb_add": ["expr'mk", "$eq", "lm_merge", "e_rows", "list.List.Nil", "e_cols", "e_body"], "matrices_ring_simp.symb_sub": ["symb_add", "symb_opp", "$eq"], "matrices_ring_simp.symb_mul": ["lm_distribute", "expr'mk", "$eq", "e_rows", "e_cols", "e_body"], "lineardecision.expr_bound'": ["HOL.eq", "HOL.True", "HOL.conj", "$le"], "lineardecision.eq_bound'": ["HOL.eq", "HOL.conj", "expr_bound'"], "lineardecision.ctx_bound'": ["HOL.eq", "HOL.True", "HOL.conj", "eq_bound'"], "lineardecision.ctx_impl_ctx'": ["HOL.All", "LinearDecisionIntMP.interp_ctx'", "HOL.implies", "HOL.True", "HOL.eq", "$eq", "why3.Bool.Bool.True", "HOL.conj"], "lineardecision.ctx_holds'": ["HOL.eq", "HOL.True", "$eq", "why3.Bool.Bool.True", "LinearDecisionIntMP.interp_eq'", "HOL.conj"], "lineardecision.is_eq_tbl": ["$le", "nat$nth", "HOL.All", "ctx_holds'", "MP64Coeffs.Var", "HOL.conj", "HOL.implies", "HOL.eq", "Int.int", "HOL.True", "$eq", "$lt", "MP64Coeffs.interp_exp", "Int.nat", "length$nat"], "imp.results_extend": ["state_extends", "HOL.All", "HOL.implies", "HOL.eq", "HOL.disj", "set.Fset.mem"], "imp.sym_state'eq": ["constr", "HOL.eq", "$eq", "vars", "rho", "sigma", "HOL.conj"], "imp.exec_cmd": ["Cnormal", "Eunbound_var", "eval_expr", "$eq", "HOL.Not", "Enormal"], "imp.exec_while1": ["Cnormal", "$le", "HOL.False", "Eunbound_var", "HOL.True", "eval_expr", "$eq", "$lt", "HOL.Not", "loop_limit", "Enormal", "$plus"], "my_lse.u_sum_of_u_exp": ["u_exp_fun", "my_sum.Sum.u_sum", "$eq"], "my_lse.lse_exact": ["sum_real.Sum.sum", "real.ExpLog.log", "exp_fun", "$eq"], "blocking_semantics5.msubst_term": ["Syntax.Tvar", "Syntax.Tbin", "$eq", "HOL.If"], "blocking_semantics5.msubst": ["Syntax.Fand", "Syntax.Fforall", "Syntax.Fnot", "Syntax.Fterm", "Syntax.Flet", "$eq", "msubst_term", "Syntax.Fimplies"], "blocking_semantics5.fresh_in_term": ["HOL.eq", "HOL.True", "$eq", "HOL.Not", "HOL.conj"], "blocking_semantics5.fresh_in_fmla": ["HOL.eq", "fresh_in_term", "$eq", "HOL.Not", "HOL.conj"], "udouble.uadd": ["$eq", "to_real", "$plus", "ieee_float.RoundingMode.RNE", "uround"], "udouble.usub": ["$eq", "$minus", "to_real", "ieee_float.RoundingMode.RNE", "uround"], "udouble.umul": ["$times", "$eq", "to_real", "ieee_float.RoundingMode.RNE", "uround"], "udouble.udiv": ["$eq", "to_real", "real.Real.infix_sl", "ieee_float.RoundingMode.RNE", "uround"], "udouble.uminus": ["$eq", "to_real", "$uminus", "ieee_float.RoundingMode.RNE", "uround"], "wp2.eval_bin": ["$le", "HOL.If", "Vbool", "$times", "$eq", "why3.Bool.Bool.True", "why3.Bool.Bool.False", "Vint", "$minus", "$plus"], "wp2.eval_term": ["Vint", "$eq", "eval_bin"], "wp2.eval_fmla": ["HOL.All", "Vbool", "HOL.implies", "HOL.eq", "$eq", "why3.Bool.Bool.True", "HOL.Not", "Vint", "HOL.conj", "eval_term", "map.Map.set"], "wp2.subst_term": ["Tbin", "HOL.If", "Tvar", "$eq"], "wp2.fresh_in_term": ["HOL.eq", "HOL.True", "$eq", "HOL.Not", "HOL.conj"], "wp2.fresh_in_fmla": ["HOL.eq", "fresh_in_term", "$eq", "HOL.Not", "HOL.conj"], "wp2.subst": ["Fterm", "subst_term", "$eq", "Flet", "Fimplies", "Fforall", "Fnot", "Fand"], "blocking_semantics5.get_stack": ["Syntax.Vvoid", "$eq", "HOL.If"], "wp2.assigns": ["HOL.All", "HOL.implies", "HOL.eq", "$eq", "set.Fset.mem", "HOL.Not"], "blocking_semantics5.valid_triple": ["HOL.All", "Syntax.Sskip", "HOL.implies", "HOL.eq", "SemOp.eval_fmla", "SemOp.many_steps"], "blocking_semantics5.total_valid_triple": ["HOL.All", "Syntax.Sskip", "HOL.implies", "HOL.eq", "HOL.Ex", "SemOp.eval_fmla", "HOL.conj", "SemOp.many_steps"], "blocking_semantics5.compatible_env": ["HOL.All", "HOL.eq", "$eq", "SemOp.get_stack", "Typing.type_value", "HOL.conj", "Typing.get_vartype"], "ringdecision.interp": ["$times", "infix_pl", "morph", "asub", "$eq", "atimes", "aplus", "$plus", "infix_dl", "infix_as"], "ringdecision.eq": ["HOL.eq", "HOL.All", "interp", "$eq"], "ringdecision.mon": ["$times", "$eq", "aone", "atimes", "one", "infix_as"], "ringdecision.interp'": ["zero", "$times", "azero", "infix_pl", "morph", "$eq", "aplus", "mon", "$plus", "infix_dl", "infix_as"], "ringdecision.eq_mon": ["mon", "HOL.eq", "HOL.All", "$eq"], "ringdecision.eq'": ["HOL.eq", "interp'", "HOL.All", "$eq"], "lineardecision.rinterp": ["real.FromInt.from_int", "real.Real.infix_sl", "$eq"], "blocking_semantics5.eval_bin": ["Syntax.Vbool", "$le", "HOL.If", "$times", "Syntax.Vint", "$eq", "why3.Bool.Bool.True", "why3.Bool.Bool.False", "$minus", "Syntax.Vvoid", "$plus"], "blocking_semantics5.eval_term": ["get_stack", "$eq", "eval_bin"], "blocking_semantics5.eval_fmla": ["Syntax.Vbool", "HOL.All", "HOL.conj", "HOL.implies", "Syntax.Vint", "HOL.eq", "$eq", "why3.Bool.Bool.True", "HOL.Not", "list.List.Cons", "Syntax.Vvoid", "eval_term"], "blocking_semantics5.valid_fmla": ["HOL.eq", "eval_fmla", "HOL.All"], "blocking_semantics5.one_step": ["Syntax.Vbool", "eval_fmla", "$eq", "why3.Bool.Bool.True", "why3.Bool.Bool.False", "eval_term", "map.Map.set"], "blocking_semantics5.many_steps": ["one_step"], "ringdecision.append_mon": ["$append", "infix_as'", "rtimes", "$times", "$eq", "M"], "ringdecision.mul_mon": ["list.List.Nil", "append_mon", "$eq", "list.List.Cons"], "ringdecision.mul_devel": ["$append", "$eq", "list.List.Nil", "M", "mul_mon"], "ringdecision.conv": ["$append", "rone", "ropp", "ext", "one1", "$eq", "mul_devel", "list.List.Cons", "list.List.Nil", "$uminus", "M"], "ringdecision.insert": ["$le", "HOL.If", "$eq", "list.List.Cons", "list.List.Nil"], "ringdecision.insertion_sort": ["list.List.Nil", "$eq", "insert"], "ringdecision.sort_mon": ["M", "insertion_sort", "$eq"], "ringdecision.sort_mons": ["sort_mon", "list.List.Nil", "$eq", "list.List.Cons"], "ringdecision.le_mon": ["HOL.If", "$eq", "why3.Bool.Bool.True", "why3.Bool.Bool.False", "$lt", "length$nat"], "ringdecision.same": ["why3.Bool.Bool.False", "$eq", "why3.Bool.Bool.True", "HOL.If"], "strassen.set": ["$le", "HOL.If", "result", "create", "$eq", "result1", "HOL.conj", "result2"], "strassen.infix_eqeq": ["$le", "HOL.All", "HOL.implies", "HOL.eq", "$eq", "get"], "strassen.infix_eqeqeq": ["$le", "HOL.All", "HOL.implies", "row_zeros", "HOL.eq", "$eq", "col_zeros", "HOL.conj"], "strassen.in_bounds": ["$le", "row_zeros", "HOL.eq", "$lt", "col_zeros", "HOL.conj"], "strassen.size": ["$le", "HOL.All", "HOL.implies", "row_zeros", "HOL.eq", "$eq", "col_zeros", "HOL.conj"], "strassen.fcreate": ["create", "result3", "$eq", "result4"], "strassen.mzero": ["fc", "fcreate", "$eq"], "strassen.zerorc": ["fcreate", "$eq", "fc1"], "strassen.idf": ["$eq", "HOL.If"], "strassen.id1": ["create", "$eq", "idf_closure", "result5", "result6"], "strassen.idrc": ["fcreate", "$eq", "idf_closure"], "strassen.f_add": ["add2f", "create", "fc2", "fc3", "$eq"], "strassen.f_opp": ["col_zeros_closure", "create", "row_zeros_closure", "$eq", "opp2f"], "strassen.sub": ["$eq", "add", "opp"], "strassen.mul_cell_bound": ["row_zeros", "int.MinMax.min", "col_zeros", "$eq"], "strassen.f_mul": ["create", "$eq", "mul_cell", "fc4", "fc5"], "strassen.f_extp": ["col_zeros_closure", "extf", "create", "row_zeros_closure", "$eq"], "wp2.stmt_writes": ["HOL.eq", "HOL.True", "HOL.conj", "set.Fset.mem"], "blocking_semantics5.wp": ["FreshVariables.msubst", "Syntax.Fand", "Syntax.Fnot", "Syntax.Fterm", "Syntax.Flet", "$eq", "fresh_from", "HOL.Let", "Syntax.Fimplies", "abstract_effects"], "ringdecision.ext": ["rtimes", "$times", "$eq", "list.List.Cons", "list.List.Nil", "M"], "ringdecision.insert_mon": ["$plus", "eq0", "HOL.If", "rplus", "$eq", "why3.Bool.Bool.True", "HOL.Let", "infix_pl'", "list.List.Cons", "le_mon", "list.List.Nil", "same", "M"], "ringdecision.insertion_sort_mon": ["list.List.Nil", "insert_mon", "$eq"], "ringdecision.normalize": ["conv", "sort_mons", "insertion_sort_mon", "$eq"], "ISet.iset_ok": ["$lt", "list.List.Cons"], "strassen.is_finite": ["HOL.eq", "rows", "cols", "InfIntMatrix.size"], "strassen.block": ["InfIntMatrix.fcreate", "ofs2", "$eq"], "strassen.c_blocks": ["$le", "cols", "HOL.conj", "HOL.eq", "$eq", "$minus", "block", "rows"], "strassen.r_blocks": ["$le", "cols", "HOL.conj", "HOL.eq", "$eq", "$minus", "block", "rows"], "strassen.quarters": ["cols", "HOL.conj", "$times", "HOL.eq", "is_finite", "$eq", "block", "rows"], "Firstorder_symbol_impl.nat_nlsize_symbol": ["Nat.Nat.SNat", "Nat.Nat.ONat", "$eq"], "Firstorder_symbol_impl.nlsize_symbol": ["$eq"], "Firstorder_symbol_impl.nlmodel_symbol": ["$eq"], "Firstorder_symbol_impl.correct_indexes_symbol": ["HOL.eq", "HOL.True", "$le"], "Firstorder_symbol_impl.bound_depth_of_symbol_in_symbol": ["$plus", "$eq"], "wp2.one_step": ["eval_fmla", "Vbool", "$eq", "why3.Bool.Bool.True", "why3.Bool.Bool.False", "eval_term"], "wp2.many_steps": ["one_step"], "Firstorder_term_spec.nat_size_fo_term_list": ["Nat.Nat.ONat", "$eq", "HOL.Let", "Nat.Nat.SNat", "Nat.Nat.add_nat"], "Firstorder_term_spec.nat_size_fo_term": ["Nat.Nat.ONat", "Firstorder_symbol_spec.Spec.nat_size_symbol", "$eq", "HOL.Let", "Nat.Nat.SNat", "Nat.Nat.add_nat"], "Firstorder_term_spec.size_fo_term_list": ["$plus", "$eq", "HOL.Let"], "Firstorder_term_spec.size_fo_term": ["$plus", "$eq", "HOL.Let", "Firstorder_symbol_spec.Spec.size_symbol"], "Firstorder_term_spec.rename_fo_term_list": ["FONil", "$eq", "FOCons"], "Firstorder_term_spec.rename_fo_term": ["Var_fo_term", "Firstorder_symbol_spec.Spec.rename_symbol", "App", "$eq"], "Firstorder_term_spec.olifts_fo_term": ["OptionFuncs.Funcs.ocase", "OptionFuncs.Funcs.some", "rename_subst_fo_term", "option.Option.None", "$eq", "Var_fo_term", "Functions.Func.identity"], "Firstorder_term_spec.subst_fo_term_list": ["Firstorder_symbol_spec.Spec.rename_subst_symbol", "rename_subst_fo_term", "FONil", "$eq", "FOCons", "Functions.Func.identity"], "Firstorder_term_spec.subst_fo_term": ["Firstorder_symbol_spec.Spec.rename_subst_symbol", "rename_subst_fo_term", "Firstorder_symbol_spec.Spec.subst_symbol", "$eq", "App", "Functions.Func.identity"], "Firstorder_term_spec.is_symbol_free_var_in_fo_term_list": ["HOL.eq", "HOL.disj", "HOL.False"], "Firstorder_term_spec.is_fo_term_free_var_in_fo_term_list": ["HOL.eq", "HOL.disj", "HOL.False"], "Firstorder_term_spec.is_symbol_free_var_in_fo_term": ["HOL.eq", "HOL.disj", "HOL.False", "Firstorder_symbol_spec.Spec.is_symbol_free_var_in_symbol"], "Firstorder_term_spec.is_fo_term_free_var_in_fo_term": ["HOL.eq", "$eq"], "Firstorder_term_impl.nat_nlsize_fo_term_list": ["Nat.Nat.ONat", "$eq", "HOL.Let", "Nat.Nat.SNat", "Nat.Nat.add_nat"], "Firstorder_term_impl.nat_nlsize_fo_term": ["Nat.Nat.ONat", "$eq", "HOL.Let", "Nat.Nat.SNat", "Nat.Nat.add_nat", "Firstorder_symbol_impl.Logic.nat_nlsize_symbol"], "Firstorder_term_impl.nlsize_fo_term_list": ["$plus", "$eq", "HOL.Let"], "Firstorder_term_impl.nlsize_fo_term": ["$plus", "Firstorder_symbol_impl.Logic.nlsize_symbol", "HOL.Let", "$eq"], "Firstorder_term_impl.nlmodel_fo_term_list": ["Firstorder_symbol_spec.Spec.rename_subst_symbol", "Firstorder_term_spec.Spec.FOCons", "$eq", "Firstorder_term_spec.Spec.rename_subst_fo_term", "Firstorder_term_spec.Spec.FONil", "Functions.Func.identity"], "Firstorder_term_impl.nlmodel_fo_term": ["Firstorder_symbol_spec.Spec.rename_subst_symbol", "$eq", "Firstorder_symbol_impl.Logic.nlmodel_symbol", "Firstorder_term_spec.Spec.rename_subst_fo_term", "Firstorder_term_spec.Spec.App", "Functions.Func.identity"], "Firstorder_term_impl.correct_indexes_fo_term_list": ["HOL.eq", "HOL.True", "HOL.conj"], "Firstorder_term_impl.correct_indexes_fo_term": ["$le", "HOL.True", "HOL.eq", "Firstorder_symbol_impl.Logic.correct_indexes_symbol", "HOL.conj"], "Firstorder_term_impl.bound_depth_of_symbol_in_fo_term_list": ["$lt", "$eq", "HOL.Let", "HOL.If"], "Firstorder_term_impl.bound_depth_of_fo_term_in_fo_term_list": ["$lt", "$eq", "HOL.Let", "HOL.If"], "Firstorder_term_impl.bound_depth_of_symbol_in_fo_term": ["Firstorder_symbol_impl.Logic.bound_depth_of_symbol_in_symbol", "HOL.If", "$eq", "HOL.Let", "$lt"], "Firstorder_term_impl.bound_depth_of_fo_term_in_fo_term": ["$plus", "$eq", "HOL.Let"], "Firstorder_symbol_spec.nat_size_symbol": ["Nat.Nat.SNat", "Nat.Nat.ONat", "$eq"], "Firstorder_symbol_spec.size_symbol": ["$eq"], "Firstorder_symbol_spec.rename_symbol": ["Var_symbol", "$eq"], "Firstorder_symbol_spec.olifts_symbol": ["rename_subst_symbol", "OptionFuncs.Funcs.ocase", "OptionFuncs.Funcs.some", "option.Option.None", "$eq", "Var_symbol"], "OptionFuncs.omap": ["option.Option.None", "option.Option.Some", "$eq"], "Firstorder_symbol_spec.subst_symbol": ["$eq"], "OptionFuncs.olift": ["Functions.Func.compose", "option.Option.None", "$eq", "ocase", "some"], "Firstorder_symbol_spec.is_symbol_free_var_in_symbol": ["HOL.eq", "$eq"], "lineardecision.m_expr": ["LinearDecisionRationalMP.ProdR", "m_cprod", "$eq", "LinearDecisionRationalMP.Var", "LinearDecisionRationalMP.ProdL", "m", "LinearDecisionRationalMP.Coeff", "LinearDecisionRationalMP.Diff", "LinearDecisionRationalMP.Sum"], "lineardecision.m_eq": ["$eq", "m_expr"], "Nat.nat_to_int": ["$plus", "$eq"], "Nat.add_nat": ["SNat", "$eq"], "Predicates.predExtensionalEqual": ["HOL.eq", "HOL.All", "why3.Bool.Bool.True", "$eq"], "Predicates.evalp": ["HOL.eq", "$eq", "why3.Bool.Bool.True"], "Functions.extensionalEqual": ["HOL.eq", "HOL.All", "$eq"], "Unification.unassigned": ["HOL.eq", "HOL.True", "HOL.False", "BacktrackArray.Types.table"], "lineardecision.meq": ["HOL.eq", "RationalCoeffs.req", "HOL.disj", "pure_same_exp", "HOL.conj"], "lineardecision.m_ctx": ["list.List.Nil", "m_eq", "$eq", "list.List.Cons"], "lineardecision.req": ["HOL.eq", "$times", "HOL.disj", "$eq", "HOL.Not", "HOL.conj"], "lineardecision.interp_term": ["$eq", "add"], "lineardecision.interp_fmla": ["HOL.All", "HOL.If", "interp_term", "$eq", "why3.Bool.Bool.True", "why3.Bool.Bool.False", "foo", "$minus", "map.Map.set"]}